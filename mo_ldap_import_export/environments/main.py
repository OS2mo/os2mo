# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import asyncio
import string
from collections.abc import AsyncIterator
from collections.abc import Awaitable
from collections.abc import Callable
from contextlib import suppress
from datetime import UTC
from datetime import datetime
from functools import partial
from typing import Any
from typing import ParamSpec
from typing import Protocol
from typing import TypeVar
from typing import cast
from uuid import UUID
from uuid import uuid4

import structlog
from fastapi.encoders import jsonable_encoder
from fastramqpi.ramqp import AMQPSystem
from fastramqpi.ramqp.mo import MOAMQPSystem
from fastramqpi.ramqp.utils import RequeueMessage
from jinja2 import Environment
from jinja2 import StrictUndefined
from jinja2 import TemplateRuntimeError
from jinja2 import UndefinedError
from jinja2.utils import missing
from ldap3.utils.dn import safe_dn
from ldap3.utils.dn import to_dn
from more_itertools import first
from more_itertools import last
from more_itertools import one
from more_itertools import only
from more_itertools import unzip
from pydantic import BaseModel
from pydantic import parse_obj_as

from ..autogenerated_graphql_client.addresses import AddressesAddresses
from ..autogenerated_graphql_client.base_model import UNSET
from ..autogenerated_graphql_client.base_model import UnsetType
from ..autogenerated_graphql_client.client import GraphQLClient
from ..autogenerated_graphql_client.input_types import AddressFilter
from ..autogenerated_graphql_client.input_types import ClassFilter
from ..autogenerated_graphql_client.input_types import EmployeeFilter
from ..autogenerated_graphql_client.input_types import EngagementFilter
from ..autogenerated_graphql_client.input_types import FacetFilter
from ..autogenerated_graphql_client.input_types import ITSystemFilter
from ..autogenerated_graphql_client.input_types import ITUserFilter
from ..autogenerated_graphql_client.input_types import ManagerFilter
from ..autogenerated_graphql_client.input_types import OrganisationUnitFilter
from ..autogenerated_graphql_client.input_types import OrgUnitsboundmanagerfilter
from ..autogenerated_graphql_client.input_types import RoleBindingFilter
from ..autogenerated_graphql_client.itusers import ItusersItusers
from ..autogenerated_graphql_client.resolve_dar_address import (
    ResolveDarAddressAddressesObjectsCurrentResolveDARAddress,
)
from ..config import Settings
from ..dataloaders import DataLoader
from ..dataloaders import NoGoodLDAPAccountFound
from ..exceptions import NoObjectsReturnedException
from ..exceptions import SkipObject
from ..exceptions import UUIDNotFoundException
from ..ldap import get_ldap_object
from ..ldap import is_uuid
from ..ldap_emit import publish_uuids
from ..ldapapi import LDAPAPI
from ..moapi import MOAPI
from ..moapi import extract_current_or_latest_validity
from ..moapi import flatten_validities
from ..moapi import get_primary_engagement
from ..models import Address
from ..models import Class
from ..models import Engagement
from ..models import ITSystem
from ..models import ITUser
from ..models import OrganisationUnit
from ..types import DN
from ..types import LDAPUUID
from ..types import EmployeeUUID
from ..types import EngagementUUID
from ..types import OrgUnitUUID
from ..utils import MO_TZ
from ..utils import ensure_list
from ..utils import extract_ou_from_dn
from ..utils import get_delete_flag
from ..utils import mo_today
from .generate_username import generate_username
from .generate_username import generate_username_permutation

logger = structlog.stdlib.get_logger()
P = ParamSpec("P")
T = TypeVar("T")


def filter_mo_datestring(datetime_object):
    """
    Converts a datetime object to a date string which is accepted by MO.

    Notes
    -------
    MO only accepts date objects dated at midnight.
    """
    # TODO: should take timezone-aware datetime_object and convert using MO_TZ.
    if not datetime_object:
        return None
    return datetime_object.strftime("%Y-%m-%dT00:00:00")


def filter_strftime(datetime_object: datetime, format: str) -> str:
    """Format datetime to string."""
    return datetime_object.strftime(format)


def filter_strptime(date_string: str, format: str) -> datetime:
    """Parse string to datetime."""
    return datetime.strptime(date_string, format)


def filter_strip_non_digits(input_string):
    if not isinstance(input_string, str):
        return None
    return "".join(c for c in input_string if c in string.digits)


def filter_remove_curly_brackets(text: str) -> str:
    # TODO: Should this remove everything or just a single set?
    return text.replace("{", "").replace("}", "")


def bitwise_and(input: int, bitmask: int) -> int:
    """Bitwise and jinja filter.

    Mostly useful for accessing bits within userAccountControl.

    Args:
        input: The input integer.
        bitmask: The bitmask to filter the input through.

    Returns:
        The bitwise and on input and bitmask.
    """
    return input & bitmask


async def _get_facet_class_uuid(
    graphql_client: GraphQLClient, class_user_key: str, facet_user_key: str
) -> str:
    result = await graphql_client.read_class_uuid_by_facet_and_class_user_key(
        facet_user_key, class_user_key
    )
    exception = UUIDNotFoundException(
        f"class not found, facet_user_key: {facet_user_key} class_user_key: {class_user_key}"
    )
    return str(one(result.objects, too_short=exception).uuid)


get_employee_address_type_uuid = partial(
    _get_facet_class_uuid, facet_user_key="employee_address_type"
)
get_visibility_uuid = partial(_get_facet_class_uuid, facet_user_key="visibility")
get_org_unit_type_uuid = partial(_get_facet_class_uuid, facet_user_key="org_unit_type")
get_engagement_type_uuid = partial(
    _get_facet_class_uuid, facet_user_key="engagement_type"
)
get_primary_type_uuid = partial(_get_facet_class_uuid, facet_user_key="primary_type")


async def get_org_unit_path_string(
    graphql_client: GraphQLClient, org_unit_path_string_separator: str, uuid: str | UUID
) -> str:
    uuid = uuid if isinstance(uuid, UUID) else UUID(uuid)
    result = await graphql_client.read_org_unit_ancestor_names(uuid)
    current = one(result.objects).current
    assert current is not None
    names = [x.name for x in reversed(current.ancestors)] + [current.name]
    assert org_unit_path_string_separator not in names
    return org_unit_path_string_separator.join(names)


# TODO: Clean this up so it always just takes an UUID
async def get_org_unit_name_for_parent(
    graphql_client: GraphQLClient, uuid: UUID | str, layer: int = 0
) -> str | None:
    """Get the name of the ancestor in the n'th layer of the org tree.

    Example:

        Imagine an org-unit tree like the following:
            ```
            └── Kolding Kommune
                └── Sundhed
                    ├── Plejecentre
                    │   ├── Plejecenter Nord
                    │   │   └── Køkken <-- uuid of this provided
                    │   └── Plejecenter Syd
                    │       └── Køkken
                    └── Teknik
            ```

        Calling this function with the uuid above and layer, would return:

        * 0: "Kolding Kommune"
        * 1: "Sundhed"
        * 2: "Plejecentre"
        * 3: "Plejecenter Nord"
        * 4: "Køkken"
        * n: ""

    Args:
        graphql_client: GraphQLClient to fetch org-units from MO with.
        uuid: Organisation Unit UUID of the org-unit to find ancestors of.
        layer: The layer the ancestor to extract is on.

    Returns:
        The name of the ancestor at the n'th layer above the provided org-unit.
        If the layer provided is beyond the depth available None is returned.
    """
    uuid = uuid if isinstance(uuid, UUID) else UUID(uuid)
    result = await graphql_client.read_org_unit_ancestor_names(uuid)
    current = one(result.objects).current
    assert current is not None
    names = [x.name for x in reversed(current.ancestors)] + [current.name]
    with suppress(IndexError):
        return names[layer]
    return None


async def get_job_function_name(graphql_client: GraphQLClient, uuid: UUID) -> str:
    result = await graphql_client.read_class_name_by_class_uuid(uuid)
    job_function = one(result.objects)
    if job_function.current is None:
        raise NoObjectsReturnedException(f"job_function not active, uuid: {uuid}")
    return job_function.current.name


async def get_org_unit_name(graphql_client: GraphQLClient, uuid: UUID) -> str:
    result = await graphql_client.read_org_unit_name(uuid)
    org_unit = one(result.objects)
    if org_unit.current is None:
        raise NoObjectsReturnedException(f"org_unit not active, uuid: {uuid}")
    return org_unit.current.name


async def _create_facet_class(
    moapi: MOAPI, class_user_key: str, facet_user_key: str
) -> UUID:
    """Creates a class under the specified facet in MO.

    Args:
        dataloader: Our dataloader instance
        facet_user_key: User-key of the facet to create the class under.
        class_user_key: The name/user-key to give the class.

    Returns:
        The uuid of the created class
    """
    logger.info("Creating MO class", facet_user_key=facet_user_key, name=class_user_key)
    facet_uuid = await moapi.load_mo_facet_uuid(facet_user_key)
    if facet_uuid is None:
        raise NoObjectsReturnedException(
            f"Could not find facet with user_key = '{facet_user_key}'"
        )
    return await moapi.create_mo_class(
        name=class_user_key, user_key=class_user_key, facet_uuid=facet_uuid
    )


async def _get_or_create_facet_class(
    moapi: MOAPI,
    class_user_key: str,
    facet_user_key: str,
    default: str | None = None,
) -> str:
    if not class_user_key:
        if default is None:
            raise UUIDNotFoundException("Cannot create class without user-key")
        logger.info("class_user_key is empty, using provided default", default=default)
        class_user_key = default
    try:
        return await _get_facet_class_uuid(
            moapi.graphql_client,
            class_user_key=class_user_key,
            facet_user_key=facet_user_key,
        )
    except UUIDNotFoundException:
        uuid = await _create_facet_class(
            moapi,
            class_user_key=class_user_key,
            facet_user_key=facet_user_key,
        )
        return str(uuid)


get_or_create_job_function_uuid = partial(
    _get_or_create_facet_class, facet_user_key="engagement_job_function"
)


async def load_primary_engagement(
    moapi: MOAPI,
    employee_uuid: UUID,
    return_terminated: bool = False,
) -> Engagement | None:
    primary_engagement_uuid = await get_primary_engagement(
        moapi.graphql_client, EmployeeUUID(employee_uuid)
    )
    if primary_engagement_uuid is None:
        logger.info(
            "Could not find primary engagement UUID", employee_uuid=employee_uuid
        )
        return None

    fetched_engagement = await moapi.load_mo_engagement(
        primary_engagement_uuid, start=None, end=None
    )
    if fetched_engagement is None:  # pragma: no cover
        logger.error("Unable to load mo engagement", uuid=primary_engagement_uuid)
        raise RequeueMessage("Unable to load mo engagement")
    # If allowed to return terminated, there is no reason to check for it
    # we simply return whatever we found and use that
    if return_terminated:
        return fetched_engagement
    delete = get_delete_flag(jsonable_encoder(fetched_engagement))
    if delete:
        logger.debug("Primary engagement is terminated", uuid=primary_engagement_uuid)
        return None
    return fetched_engagement


async def load_engagement(moapi: MOAPI, uuid: UUID) -> Engagement | None:
    fetched_engagement = await moapi.load_mo_engagement(uuid, start=None, end=None)
    if fetched_engagement is None:  # pragma: no cover
        logger.error("Unable to load mo engagement", uuid=uuid)
        raise RequeueMessage("Unable to load mo engagement")
    delete = get_delete_flag(jsonable_encoder(fetched_engagement))
    if delete:
        logger.debug("Engagement is terminated", uuid=uuid)
        return None
    return fetched_engagement


async def load_org_unit(moapi: MOAPI, uuid: UUID) -> OrganisationUnit | None:
    fetched_org_unit = await moapi.load_mo_org_unit(uuid, current_objects_only=False)
    if fetched_org_unit is None:  # pragma: no cover
        logger.error("Unable to load mo org_unit", uuid=uuid)
        raise RequeueMessage("Unable to load mo org_unit")
    delete = get_delete_flag(jsonable_encoder(fetched_org_unit))
    if delete:
        logger.debug("Org unit is terminated", uuid=uuid)
        return None
    return fetched_org_unit


async def load_it_user(
    moapi: MOAPI,
    filter: dict[str, Any],
    return_terminated: bool = False,
) -> ITUser | None:
    ituser_filter = parse_obj_as(ITUserFilter, filter)
    result = await moapi.graphql_client.read_filtered_itusers(ituser_filter)
    if not result.objects:
        logger.info("Could not find it-user", filter=ituser_filter)
        return None
    # Flatten all validities to a list
    validities = list(flatten_validities(result))
    validity = extract_current_or_latest_validity(validities)
    if validity is None:  # pragma: no cover
        logger.error("No active validities on it-user", filter=ituser_filter)
        raise RequeueMessage("No active validities on it-user")
    fetched_ituser = await moapi.load_mo_it_user(
        validity.uuid, current_objects_only=False
    )
    if fetched_ituser is None:  # pragma: no cover
        logger.error("Unable to load it-user", uuid=validity.uuid)
        raise RequeueMessage("Unable to load it-user")
    # If allowed to return terminated, there is no reason to check for it
    # we simply return whatever we found and use that
    if return_terminated:
        return fetched_ituser
    delete = get_delete_flag(jsonable_encoder(fetched_ituser))
    if delete:
        logger.debug("IT-user is terminated", uuid=validity.uuid)
        return None
    return fetched_ituser


async def mo_itusers(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> ItusersItusers:
    ituser_filter = parse_obj_as(ITUserFilter, filter)
    return await graphql_client.itusers(ituser_filter)


async def mo_addresses(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> AddressesAddresses:
    addresses_filter = parse_obj_as(AddressFilter, filter)
    return await graphql_client.addresses(addresses_filter)


async def create_mo_it_user(moapi: MOAPI, it_user: dict[str, Any]) -> ITUser | None:
    it_user_object = parse_obj_as(ITUser, it_user)
    assert it_user_object.person is not None
    uuid = await moapi.create_ituser(it_user_object)
    return await load_it_user(
        moapi,
        ITUserFilter(
            uuids=[uuid],
            from_date=None,
            to_date=None,
        ).dict(exclude_unset=True),
    )


async def load_address(
    moapi: MOAPI, employee_uuid: UUID, address_type_user_key: str
) -> Address | None:
    result = await moapi.graphql_client.read_filtered_addresses(
        AddressFilter(
            employee=EmployeeFilter(uuids=[employee_uuid]),
            address_type=ClassFilter(user_keys=[address_type_user_key]),
            from_date=None,
            to_date=None,
        )
    )
    if not result.objects:
        logger.info(
            "Could not find employee address",
            employee_uuid=employee_uuid,
            address_type_user_key=address_type_user_key,
        )
        return None
    # Flatten all validities to a list
    validities = list(flatten_validities(result))
    validity = extract_current_or_latest_validity(validities)
    if validity is None:  # pragma: no cover
        logger.error(
            "No active validities on employee address",
            employee_uuid=employee_uuid,
            address_type_user_key=address_type_user_key,
        )
        raise RequeueMessage("No active validities on employee address")
    fetched_address = await moapi.load_mo_address(
        validity.uuid, current_objects_only=False
    )
    if fetched_address is None:  # pragma: no cover
        logger.error("Unable to load employee address", uuid=validity.uuid)
        raise RequeueMessage("Unable to load employee address")
    delete = get_delete_flag(jsonable_encoder(fetched_address))
    if delete:
        logger.debug("Employee address is terminated", uuid=validity.uuid)
        return None
    return fetched_address


async def load_org_unit_address(
    moapi: MOAPI, employee_uuid: UUID, address_type_user_key: str
) -> Address | None:
    primary_engagement_uuid = await get_primary_engagement(
        moapi.graphql_client, EmployeeUUID(employee_uuid)
    )
    if primary_engagement_uuid is None:
        logger.info(
            "Could not find primary engagement UUID", employee_uuid=employee_uuid
        )
        return None

    result = await moapi.graphql_client.read_filtered_addresses(
        AddressFilter(
            # TODO: Use primary engagement filter here
            org_unit=OrganisationUnitFilter(
                engagement=EngagementFilter(uuids=[primary_engagement_uuid])
            ),
            address_type=ClassFilter(user_keys=[address_type_user_key]),
            from_date=None,
            to_date=None,
        )
    )
    if not result.objects:
        logger.info(
            "Could not find org-unit address",
            employee_uuid=employee_uuid,
            address_type_user_key=address_type_user_key,
        )
        return None
    # Flatten all validities to a list
    validities = list(flatten_validities(result))
    validity = extract_current_or_latest_validity(validities)
    if validity is None:  # pragma: no cover
        logger.error(
            "No active validities on org-unit address",
            employee_uuid=employee_uuid,
            address_type_user_key=address_type_user_key,
        )
        return None
    fetched_address = await moapi.load_mo_address(
        validity.uuid, current_objects_only=False
    )
    if fetched_address is None:  # pragma: no cover
        logger.error("Unable to load org-unit address", uuid=validity.uuid)
        raise RequeueMessage("Unable to load org-unit address")
    delete = get_delete_flag(jsonable_encoder(fetched_address))
    if delete:
        logger.debug("Org-unit address is terminated", uuid=validity.uuid)
        return None
    return fetched_address


async def fetch_current_common_name(ldapapi: LDAPAPI, dn: DN | None) -> str | None:
    if dn is None:
        return None
    ldap_common_name = None
    with suppress(NoObjectsReturnedException):
        ldap_common_name = await ldapapi.get_attribute_by_dn(dn, "cn")
    # It is an invariant that common name is always be set
    assert ldap_common_name is not None
    # This is a list on OpenLDAP, but not on AD
    # We use ensure_list to ensure that AD is handled like Standard LDAP
    current_common_name = one(ensure_list(ldap_common_name))
    # IT is an invariant that common name is a string
    assert current_common_name is not None
    assert isinstance(current_common_name, str)
    return current_common_name


async def generate_common_name(
    dataloader: DataLoader,
    employee_uuid: UUID,
    dn: DN | None,
) -> str:
    employee = await dataloader.moapi.load_mo_employee(employee_uuid)
    if employee is None:  # pragma: no cover
        raise NoObjectsReturnedException(f"Unable to lookup employee: {employee_uuid}")
    # Fetch the current common name (if any)
    current_common_name = await fetch_current_common_name(dataloader.ldapapi, dn)
    return cast(
        str,
        await dataloader.username_generator.generate_common_name(
            employee, current_common_name
        ),
    )


async def get_person_uuid(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> UUID | None:
    person_filter = parse_obj_as(EmployeeFilter, filter)
    result = await graphql_client.read_person_uuid(person_filter)
    obj = only(result.objects)
    return obj.uuid if obj else None


async def get_address_uuid(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> UUID | None:
    address_filter = parse_obj_as(AddressFilter, filter)
    result = await graphql_client.read_address_uuid(address_filter)
    obj = only(result.objects)
    return obj.uuid if obj else None


async def get_ituser_uuids(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> set[UUID]:
    ituser_filter = parse_obj_as(ITUserFilter, filter)
    result = await graphql_client.read_ituser_uuid(ituser_filter)
    return {obj.uuid for obj in result.objects}


async def get_ituser_uuid(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> UUID | None:
    return only(await get_ituser_uuids(graphql_client, filter))


async def get_itsystem_uuid(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> UUID | None:
    itsystem_filter = parse_obj_as(ITSystemFilter, filter)
    result = await graphql_client.read_itsystem_uuid(itsystem_filter)
    obj = only(result.objects)
    return obj.uuid if obj else None


async def get_class_uuid(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> UUID | None:
    class_filter = parse_obj_as(ClassFilter, filter)
    result = await graphql_client.read_class_uuid(class_filter)
    obj = only(result.objects)
    return obj.uuid if obj else None


async def get_facet_uuid(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> UUID | None:
    facet_filter = parse_obj_as(FacetFilter, filter)
    result = await graphql_client.read_facet_uuid(facet_filter)
    obj = only(result.objects)
    return obj.uuid if obj else None


async def get_engagement_uuid(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> UUID | None:
    engagement_filter = parse_obj_as(EngagementFilter, filter)
    result = await graphql_client.read_engagement_uuid(engagement_filter)
    obj = only(result.objects)
    return obj.uuid if obj else None


async def get_org_unit_uuid(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> UUID | None:
    org_unit_filter = parse_obj_as(OrganisationUnitFilter, filter)
    result = await graphql_client.read_org_unit_uuid(org_unit_filter)
    obj = only(result.objects)
    return obj.uuid if obj else None


async def get_legacy_manager_person_uuids(
    graphql_client: GraphQLClient, manager_filter: ManagerFilter
) -> AsyncIterator[UUID | None]:
    result = await graphql_client.read_manager_person_uuid(manager_filter, inherit=True)

    for obj in result.objects:
        # 'current' should never be none, as the object should simply be missing instead
        assert obj.current is not None
        if obj.current.person is None:
            yield None
            continue
        for person_validity in obj.current.person:
            yield person_validity.uuid


async def get_legacy_manager_for_org_unit(
    graphql_client: GraphQLClient,
    uuid: OrgUnitUUID,
    primary_manager_responsibility: UUID | None,
) -> UUID | None:
    manager_filter = ManagerFilter(
        org_unit=OrganisationUnitFilter(uuids=[uuid]),
        responsibility=ClassFilter(uuids=[primary_manager_responsibility])
        if primary_manager_responsibility
        else None,
    )
    manager_person_uuids = get_legacy_manager_person_uuids(
        graphql_client, manager_filter
    )
    vacant_found = False
    async for manager_person_uuid in manager_person_uuids:
        if manager_person_uuid is None:
            vacant_found = True
            continue
        return manager_person_uuid

    if vacant_found:
        return None

    raise ValueError("No manager found")


async def get_legacy_manager_person_uuid(
    moapi: MOAPI, uuid: EmployeeUUID, primary_manager_responsibility: UUID | None = None
) -> UUID | None:
    primary_engagement = await load_primary_engagement(moapi, uuid)
    if primary_engagement is None:
        return None

    manager_org_unit = OrgUnitUUID(primary_engagement.org_unit)
    while True:
        manager_uuid = await get_legacy_manager_for_org_unit(
            moapi.graphql_client, manager_org_unit, primary_manager_responsibility
        )
        if manager_uuid != uuid:
            return manager_uuid

        org_unit = await load_org_unit(moapi, manager_org_unit)
        if org_unit is None or org_unit.parent is None:
            return manager_uuid
        manager_org_unit = OrgUnitUUID(org_unit.parent)


async def get_employment_interval(
    graphql_client: GraphQLClient,
    employee_uuid: UUID,
    exclude_engagement_types: set[UUID] | None = None,
) -> tuple[datetime | None, datetime | None]:
    result = await graphql_client.read_engagement_enddate(employee_uuid)
    if not result.objects:
        return None, None

    tzmin = datetime.min.replace(tzinfo=MO_TZ)
    tzmax = datetime.max.replace(tzinfo=MO_TZ)

    # Flatten all validities to a list
    validities = list(flatten_validities(result))
    if exclude_engagement_types is not None:
        validities = [
            val
            for val in validities
            if val.engagement_type_response.uuid not in exclude_engagement_types
        ]
    if not validities:
        return None, None

    start_dates, end_dates = unzip(
        (validity.validity.from_ or tzmin, validity.validity.to or tzmax)
        for validity in validities
    )
    startdate = min(start_dates)
    enddate = max(end_dates)
    return startdate, enddate


async def get_manager_person_uuid(
    graphql_client: GraphQLClient,
    engagement_uuid: EngagementUUID,
    filter: dict[str, Any] | None = None,
) -> UUID | None:
    manager_filter = None
    if filter:
        manager_filter = parse_obj_as(OrgUnitsboundmanagerfilter, filter)
    result = await graphql_client.read_engagement_manager(
        engagement_uuid, manager_filter
    )

    obj = only(result.objects)
    if obj is None:
        logger.debug("Invalid engagement", engagement_uuid=engagement_uuid)
        return None

    current = obj.current
    # Our lookup is specifically for current engagements
    assert current is not None

    # NOTE: We assume that there is at most one manager in managers, as any others
    #       should have have been filtered using the manager filter.
    manager = only(current.managers)
    if manager is None:
        logger.debug(
            "No manager relation found",
            engagement_uuid=engagement_uuid,
            manager_filter=filter,
        )
        return None

    # NOTE: manager.person may be null if we hit a vacant manager position
    #       The caller can avoid this, by setting `employee: null` on the manager filter.
    if manager.person is None:
        logger.debug(
            "Vacant manager found",
            engagement_uuid=engagement_uuid,
            manager_filter=filter,
        )
        return None

    manager_validity = one(manager.person)
    return manager_validity.uuid


async def get_person_dn(dataloader: DataLoader, uuid: EmployeeUUID) -> DN | None:
    with suppress(NoGoodLDAPAccountFound):
        return await dataloader._find_best_dn(uuid)
    return None


def skip_if_none(obj: T | None) -> T:
    if obj is None:
        raise SkipObject("Skipping: Object is None")
    return obj


def skip_if_exception(func: Callable[P, Awaitable[T]]) -> Callable[P, Awaitable[T]]:
    async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
        try:
            return await func(*args, **kwargs)
        except Exception as exc:
            raise SkipObject(f"Skipping due to: '{exc}'") from exc

    return wrapper


def requeue_if_none(obj: T | None) -> T:
    if obj is None:
        raise RequeueMessage("Requeueing: Object is None")
    return obj


def assert_not_none(obj: T | None) -> T:
    assert obj is not None, "assert_not_none failed"
    return obj


def parent_dn(dn: DN) -> DN:
    dn_parts = to_dn(dn)
    parent_dn_parts = dn_parts[1:]
    return cast(DN, safe_dn(parent_dn_parts))


def dn_has_ou(dn: DN) -> bool:
    return bool(extract_ou_from_dn(dn))


async def dn_exists(ldapapi: LDAPAPI, dn: DN) -> bool:
    with suppress(NoObjectsReturnedException):
        await ldapapi.get_object_by_dn(dn, set())
        return True
    return False


async def get_class(dataloader: DataLoader, uuid: UUID) -> Class | None:
    return await dataloader.moapi.load_mo_class(uuid)


async def get_itsystem(dataloader: DataLoader, uuid: UUID) -> ITSystem | None:
    return await dataloader.moapi.load_mo_it_system(uuid)


async def role_uuid_to_person_uuids(
    graphql_client: GraphQLClient, uuid: UUID
) -> set[UUID]:
    result = await graphql_client.read_rolebindings(
        filter=RoleBindingFilter(role=ClassFilter(uuids=[uuid]))
    )
    person_uuids = set()
    for obj in result.objects:
        if obj.current is None:  # pragma: no cover
            continue
        for ituser_validity in obj.current.ituser:
            if ituser_validity.person is None:  # pragma: no cover
                continue
            for person_validity in ituser_validity.person:
                person_uuids.add(person_validity.uuid)
    return person_uuids


async def itsystem_uuid_to_person_uuids(
    graphql_client: GraphQLClient, uuid: UUID
) -> set[UUID]:
    result = await graphql_client.read_filtered_itusers(
        filter=ITUserFilter(itsystem=ITSystemFilter(uuids=[uuid]))
    )
    return {
        validity.employee_uuid
        for obj in result.objects
        for validity in obj.validities
        if validity.employee_uuid is not None
    }


async def rolebinding_uuid_to_role_uuid(
    graphql_client: GraphQLClient, uuid: UUID
) -> UUID | None:
    result = await graphql_client.read_rolebindings(
        filter=RoleBindingFilter(uuid=[uuid])
    )
    role_binding = only(result.objects)
    if role_binding is None or role_binding.current is None:
        return None
    # UUID cannot change for different validities
    return one({role_validity.uuid for role_validity in role_binding.current.role})


async def itsystem_uuid_to_role_uuids(
    graphql_client: GraphQLClient, uuid: UUID
) -> set[UUID]:
    result = await graphql_client.read_itsystems(uuids=[uuid])
    itsystem = only(result.objects)
    if itsystem is None:
        return set()
    return {
        role_validity.uuid
        for obj_validities in itsystem.validities
        for role_validity in obj_validities.roles
    }


async def ituser_uuid_to_rolebinding_uuids(
    graphql_client: GraphQLClient, uuid: UUID
) -> set[UUID]:
    result = await graphql_client.read_itusers(uuids=[uuid])
    ituser = only(result.objects)
    if ituser is None:
        return set()
    return {
        rolebinding_validity.uuid
        for obj_validities in ituser.validities
        for rolebinding_validity in obj_validities.rolebindings
    }


class Refresher(Protocol):
    def __call__(
        self,
        uuids: list[UUID],
        exchange: str | None | UnsetType = UNSET,
        owner: UUID | None | UnsetType = UNSET,
    ) -> Awaitable[Any]: ...


def collection2refresher(graphql_client: GraphQLClient, collection: str) -> Refresher:
    refreshers = {
        "address": graphql_client.address_refresh,
        "association": graphql_client.association_refresh,
        "class": graphql_client.class_refresh,
        "engagement": graphql_client.engagement_refresh,
        "facet": graphql_client.facet_refresh,
        "itsystem": graphql_client.itsystem_refresh,
        "ituser": graphql_client.ituser_refresh,
        "kle": graphql_client.kle_refresh,
        "leave": graphql_client.leave_refresh,
        "manager": graphql_client.manager_refresh,
        "org_unit": graphql_client.org_unit_refresh,
        "owner": graphql_client.owner_refresh,
        "person": graphql_client.person_refresh,
        "related_unit": graphql_client.related_unit_refresh,
        "rolebinding": graphql_client.rolebinding_refresh,
    }
    return refreshers[collection]


async def refresh(
    graphql_client: GraphQLClient,
    amqpsystem: MOAMQPSystem,
    collection: str,
    uuids: set[UUID],
) -> None:
    """Send events for the provided UUIDs on both AMQP and GraphQL Events."""
    # This is a noop according to the typing, but it's actually required
    # because the input is from jinja, and thus not type-checkable.
    collection = parse_obj_as(str, collection)
    uuids = parse_obj_as(set[UUID], uuids)

    logger.info("refresh called", collection=collection, uuids=uuids)
    exchange = amqpsystem.exchange_name

    result = await graphql_client.who_am_i()
    owner = result.actor.uuid

    refresher = collection2refresher(graphql_client, collection)
    await asyncio.gather(
        # Refresh on the AMQP system
        refresher(uuids=list(uuids), exchange=exchange),
        # Refresh on GraphQL events
        refresher(uuids=list(uuids), owner=owner),
    )


async def refresh_ldap(
    graphql_client: GraphQLClient,
    amqpsystem: AMQPSystem,
    uuids: set[LDAPUUID],
) -> None:
    """Send events for the provided UUIDs on both AMQP and GraphQL Events."""
    # This is a noop according to the typing, but it's actually required
    # because the input is from jinja, and thus not type-checkable.
    uuids = parse_obj_as(set[LDAPUUID], uuids)
    logger.info("refresh_ldap called", uuids=uuids)
    await publish_uuids(graphql_client, amqpsystem, list(uuids))


class DARAddress(BaseModel):
    postal_code: str
    city: str
    streetname: str
    house_number: str
    supplementary_city: str | None
    floor: str | None
    door: str | None


async def resolve_dar_address(
    graphql_client: GraphQLClient, filter: dict[str, Any]
) -> list[DARAddress]:
    address_filter = parse_obj_as(AddressFilter, filter)
    result = await graphql_client.resolve_dar_address(address_filter)

    dar_addresses = []
    for obj in result.objects:
        if obj.current is None:  # pragma: no cover
            logger.error("No active validities on address", uuid=obj.uuid)
            continue

        resolve = obj.current.resolve

        if not isinstance(
            resolve, ResolveDarAddressAddressesObjectsCurrentResolveDARAddress
        ):
            logger.warning("Resolved address is not a DAR address", uuid=obj.uuid)
            continue

        dar_addresses.append(
            DARAddress(
                postal_code=resolve.zip_code,
                city=resolve.zip_code_name,
                streetname=resolve.road_name,
                house_number=resolve.house_number,
                supplementary_city=resolve.supplementary_city,
                floor=resolve.floor,
                door=resolve.door,
            )
        )
    return dar_addresses


def construct_filters_dict(dataloader: DataLoader) -> dict[str, Any]:
    return {
        "get_person_dn": partial(get_person_dn, dataloader),
        "dn_exists": partial(dn_exists, dataloader.ldapapi),
    }


def construct_globals_dict(
    settings: Settings,
    dataloader: DataLoader,
    mo_amqpsystem: MOAMQPSystem,
    ldap_amqpsystem: AMQPSystem,
) -> dict[str, Any]:
    moapi = dataloader.moapi
    graphql_client = moapi.graphql_client
    return {
        "get_employee_address_type_uuid": partial(
            get_employee_address_type_uuid, graphql_client
        ),
        "get_it_system_uuid": partial(moapi.get_it_system_uuid),
        "get_visibility_uuid": partial(get_visibility_uuid, graphql_client),
        "get_org_unit_type_uuid": partial(get_org_unit_type_uuid, graphql_client),
        "get_org_unit_path_string": partial(
            get_org_unit_path_string,
            graphql_client,
            settings.org_unit_path_string_separator,
        ),
        "get_org_unit_name_for_parent": partial(
            get_org_unit_name_for_parent, graphql_client
        ),
        "get_job_function_name": partial(get_job_function_name, graphql_client),
        "get_org_unit_name": partial(get_org_unit_name, graphql_client),
        "get_or_create_job_function_uuid": partial(
            get_or_create_job_function_uuid, moapi
        ),
        # These names are intentionally bad, but consistent with the old code names
        # TODO: Rename these functions once the old template system is gone
        "load_mo_employee": moapi.load_mo_employee,
        "load_mo_primary_engagement": partial(load_primary_engagement, moapi),
        "load_mo_engagement": partial(load_engagement, moapi),
        "load_mo_org_unit": partial(load_org_unit, moapi),
        "load_mo_it_user": partial(load_it_user, moapi),
        "load_mo_address": partial(load_address, moapi),
        "load_mo_org_unit_address": partial(load_org_unit_address, moapi),
        "create_mo_it_user": partial(create_mo_it_user, moapi),
        "generate_username": partial(generate_username, dataloader),
        "generate_username_permutation": partial(
            generate_username_permutation, dataloader
        ),
        "generate_common_name": partial(generate_common_name, dataloader),
        "generate_dn": dataloader.make_mo_employee_dn,
        "get_person_uuid": partial(get_person_uuid, graphql_client),
        "get_address_uuid": partial(get_address_uuid, graphql_client),
        "get_ituser_uuids": partial(get_ituser_uuids, graphql_client),
        "get_ituser_uuid": partial(get_ituser_uuid, graphql_client),
        "get_itsystem_uuid": partial(get_itsystem_uuid, graphql_client),
        "get_class_uuid": partial(get_class_uuid, graphql_client),
        "get_facet_uuid": partial(get_facet_uuid, graphql_client),
        "get_engagement_uuid": partial(get_engagement_uuid, graphql_client),
        "get_org_unit_uuid": partial(get_org_unit_uuid, graphql_client),
        "get_employment_interval": partial(get_employment_interval, graphql_client),
        "get_manager_person_uuid": partial(get_manager_person_uuid, graphql_client),
        "get_person_dn": partial(get_person_dn, dataloader),
        "mo_itusers": partial(mo_itusers, graphql_client),
        "mo_addresses": partial(mo_addresses, graphql_client),
        "dn_to_uuid": dataloader.ldapapi.get_ldap_unique_ldap_uuid,
        "uuid_to_dn": dataloader.ldapapi.get_ldap_dn,
        "get_engagement_type_uuid": partial(get_engagement_type_uuid, graphql_client),
        "get_primary_type_uuid": partial(get_primary_type_uuid, graphql_client),
        "get_ldap_object": partial(get_ldap_object, dataloader.ldapapi.connection),
        "get_class": partial(get_class, dataloader),
        "get_itsystem": partial(get_itsystem, dataloader),
        "role_uuid_to_person_uuids": partial(role_uuid_to_person_uuids, graphql_client),
        "itsystem_uuid_to_person_uuids": partial(
            itsystem_uuid_to_person_uuids, graphql_client
        ),
        "rolebinding_uuid_to_role_uuid": partial(
            rolebinding_uuid_to_role_uuid, graphql_client
        ),
        "itsystem_uuid_to_role_uuids": partial(
            itsystem_uuid_to_role_uuids, graphql_client
        ),
        "ituser_uuid_to_rolebinding_uuids": partial(
            ituser_uuid_to_rolebinding_uuids, graphql_client
        ),
        "refresh": partial(refresh, graphql_client, mo_amqpsystem),
        "refresh_ldap": partial(refresh_ldap, graphql_client, ldap_amqpsystem),
        "find_mo_employee_uuid": dataloader.find_mo_employee_uuid,
        "resolve_dar_address": partial(resolve_dar_address, graphql_client),
        "get_legacy_manager_person_uuid": partial(
            get_legacy_manager_person_uuid, moapi
        ),
    }


class NeverUndefined(StrictUndefined):
    """https://github.com/pallets/jinja/issues/1923."""

    def __init__(
        self,
        hint: str | None = None,
        obj: Any = missing,
        name: str | None = None,
        exc: type[TemplateRuntimeError] = UndefinedError,
    ) -> None:
        raise Exception(
            f"Undefined variable '{name}' with object {obj} (hint: {hint})"
        ) from exc


def construct_default_environment() -> Environment:
    # We intentionally use 'StrictUndefined' here so undefined accesses yield exceptions
    # instead of silently coercing to falsy values as is the case with 'Undefined'
    # See: https://jinja.palletsprojects.com/en/3.1.x/api/#undefined-types
    # For more details.
    environment = Environment(undefined=NeverUndefined, enable_async=True)

    environment.filters["bitwise_and"] = bitwise_and
    environment.filters["mo_datestring"] = filter_mo_datestring
    environment.filters["strftime"] = filter_strftime
    environment.filters["strptime"] = filter_strptime
    environment.filters["strip_non_digits"] = filter_strip_non_digits
    environment.filters["remove_curly_brackets"] = filter_remove_curly_brackets
    environment.filters["set"] = set
    environment.filters["uuid"] = UUID

    environment.globals["now"] = lambda: datetime.now(tz=UTC)
    environment.globals["mo_today"] = mo_today
    environment.globals["skip_if_none"] = skip_if_none
    environment.globals["skip_if_exception"] = skip_if_exception
    environment.globals["requeue_if_none"] = requeue_if_none
    environment.globals["assert_not_none"] = assert_not_none
    environment.globals["uuid4"] = uuid4
    environment.globals["is_uuid"] = is_uuid
    environment.globals["parent_dn"] = parent_dn
    environment.globals["dn_has_ou"] = dn_has_ou
    environment.globals["only"] = only
    environment.globals["one"] = one
    environment.globals["first"] = first
    environment.globals["last"] = last
    environment.globals["logger"] = logger

    return environment


def construct_environment(
    settings: Settings,
    dataloader: DataLoader,
    mo_amqpsystem: MOAMQPSystem,
    ldap_amqpsystem: AMQPSystem,
) -> Environment:
    environment = construct_default_environment()
    environment.filters.update(construct_filters_dict(dataloader))
    environment.globals.update(
        construct_globals_dict(settings, dataloader, mo_amqpsystem, ldap_amqpsystem)
    )
    return environment
