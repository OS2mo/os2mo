# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
#
# OS2mo GraphQL API schema definition (v24).
# https://os2mo.eksempel.dk/graphql/v24/schema.graphql

"Address information for either an employee or organisational unit\n"
type Address {
  "The address category or type.\n\nIn OS2mo addresses can be of a variety of different types:\n* Phone numbers\n* Addresses\n* Registration numbers\n* Card codes\n\nThis field is what encodes the type of an address.\n\nExamples of user-keys:\n* `\"EmailUnit\"`\n* `\"p-nummer\"`\n* `\"PhoneEmployee\"`\n"
  address_type(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class!

  "Determines who can see the address and how it is exported.\n\nIn OS2mo addresses can be of a variety of privacy classes.\nFor instance OS2mo may contain a list of phone numbers for an employee;\n* A private mobile phone number\n* An internal work mobile phone number\n* A shared external phone number\n\nThis field is what encodes the privacy class of an address.\nThereby stating who should be allowed to see what addresses.\n\nExamples of user-keys:\n* `null`: Undetermined / non-classified.\n* `\"Secret\"`: Should be treated carefully and perhaps not be exported.\n* `\"Internal\"` Should be treated carefully but perhaps exposed to an internal intranet.\n* `\"External\"`: Can probably be exposed to the internet\n"
  visibility(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  "Connected employee.\n\nNote:\nThis field is mutually exclusive with the `org_unit` field.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  employee(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!] @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  "Connected person.\n\nNote:\nThis field is mutually exclusive with the `org_unit` field.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  person(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]

  "Connected organisation unit.\n\nNote:\nThis field is mutually exclusive with the `employee` field.\n"
  org_unit(
    filter: UuidsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [OrganisationUnit!]

  "Connected engagement.\n\nNote:\nThis field is **not** mutually exclusive with neither the `employee` nor the `org_unit` field.\n"
  engagement(
    filter: UuidsBoundEngagementFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Engagement!]

  "Connected IT-user.\n"
  ituser(
    filter: UuidsBoundITUserFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [ITUser!]!

  "Human readable name of the address.\n\nName is *usually* equal to `value`, but may differ if `value` is not human readable.\nThis may for instance be the case for `DAR` addresses, where the value is the DAR UUID, while the name is a human readable address.\n\nThis is the value that should be shown to users in UIs.\n\nExamples:\n* `\"Vifdam 20, 1. th, 6000 Kolding\"`\n* `\"25052943\"`\n* `\"info@magenta.dk\"`\n* `\"Building 11\"`\n\nNote:\nRequesting this field may incur a performance penalty as the returned value may be dynamically resolved from the `value`-field.\n"
  name: String
  resolve: ResolvedAddress!

  "Hypertext Reference of the address.\n\nThe `href` field makes a hyperlink from the address value, such that the link can be included in user interfaces.\n\nExamples:\n* `null`: For non-hyperlinkable addresses.\n* `\"tel:88888888\"`: For phone numbers.\n* `\"mailto:info@magenta.dk\"`: For email addresses.\n* `\"https://www.openstreetmap.org/?mlon=11&mlat=56\"`: For postal addresses, locations, etc\n\nNote:\nRequesting this field may incur a performance penalty as the returned value may be dynamically resolved from the `value`-field.\n\n"
  href: String

  """UUID of the entity"""
  uuid: UUID!

  "Short unique key.\n\nUsually set to the `value` provided on object creation.\nMay also be set to the key used in external systems.\n\nExamples:\n* `\"25052943\"`\n* `\"info@magenta.dk\"`\n* `\"Building 11\"`\n"
  user_key: String!

  "The object type.\n\nAlways contains the string `address`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the address type class."""
  address_type_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `address_type {uuid}` instead.\n")

  """UUID of the employee related to the address."""
  employee_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `employee {uuid}` instead.\n")

  """UUID of the organisation unit related to the address."""
  org_unit_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `org_unit {uuid}` instead.\n")

  """Optional UUID of an associated engagement."""
  engagement_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `engagement {uuid}` instead.\n")

  """UUID of the visibility class of the address."""
  visibility_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `visibility {uuid}` instead.\n")

  "Machine processable value of the address.\n\nThe value of the address, which may or may not be fit for human consumption.\nIf an address for human consumption is required, consider using `name` or `href` instead.\n\nExamples:\n* `\"3cb0a0c6-37d0-0e4a-e044-0003ba298018\"`\n* `\"25052943\"`\n* `\"info@magenta.dk\"`\n* `\"Building 11\"`\n"
  value: String!

  "Optional second machine processable value of the address.\n\nThis value is `null` for most address types, but may be utilized by some address-types for extra information.\n\nExamples:\n* `null`\n* `\"Office 12\"`\n* `\"+45\"`\n"
  value2: String

  "Same as address_type, but with HACKs to enable validities.\n"
  address_type_validity: Class @deprecated(reason: "Should only be used to query address_type when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  """Validity of the address object."""
  validity: Validity!
}

input AddressCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """UUID for the related org unit."""
  org_unit: UUID = null

  """UUID for the related person."""
  person: UUID = null

  """UUID for the related person."""
  employee: UUID = null @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  """UUID for the related engagement."""
  engagement: UUID = null

  """UUID for the related ituser."""
  ituser: UUID = null

  """Visibility for the address."""
  visibility: UUID = null

  """Validity range for the org-unit."""
  validity: RAValidityInput!

  """User key of the address. If None, defaults to value"""
  user_key: String = null

  """The actual address value."""
  value: String!

  """Type of the address."""
  address_type: UUID!
}

"""Address filter."""
input AddressFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Employee filter limiting which entries are returned.\n"
  employee: EmployeeFilter = null

  "Employee UUID filter limiting which entries are returned.\n\n| `employees`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  employees: [UUID!] = null @deprecated(reason: "Replaced by the 'employee' filter")

  "Organisation Unit filter limiting which entries are returned.\n"
  org_unit: OrganisationUnitFilter = null

  "Organisational Unit UUID filter limiting which entries are returned.\n\n| `org_units`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  org_units: [UUID!] = null @deprecated(reason: "Replaced by the 'org_unit' filter")

  "Registration filter limiting which entries are returned.\n"
  registration: AddressRegistrationFilter = null

  "Address type filter limiting which entries are returned.\n"
  address_type: ClassFilter = null

  "Address type UUID filter limiting which entries are returned.\n\n| `address_types`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  address_types: [UUID!] = null @deprecated(reason: "Replaced by the 'address_type' filter")

  "Address type user-key filter limiting which entries are returned.\n\n| `address_type_user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  address_type_user_keys: [String!] = null @deprecated(reason: "Replaced by the 'address_type' filter")

  "Engagement filter limiting which entries are returned.\n"
  engagement: EngagementFilter = null

  "Engagement UUID filter limiting which entries are returned.\n\n| `engagements`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  engagements: [UUID!] = null @deprecated(reason: "Replaced by the 'engagement' filter")

  """ITUser filter limiting which entries are returned."""
  ituser: ITUserFilter = null

  """Visibility filter limiting which entries are returned."""
  visibility: ClassFilter = null
}

"""Address registration filter."""
input AddressRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type AddressResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): Address

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [Address!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [Address!]!
}

"""Result page in cursor-based pagination."""
type AddressResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [AddressResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input AddressTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID for the address we want to terminate."""
  uuid: UUID!
}

input AddressUpdateInput {
  """UUID of the address we want to update."""
  uuid: UUID!

  """UUID for the related org unit."""
  org_unit: UUID = null

  """UUID for the related person."""
  person: UUID = null

  """UUID for the related person."""
  employee: UUID = null @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  """UUID for the related engagement."""
  engagement: UUID = null

  """UUID for the related ituser."""
  ituser: UUID = null

  """Visibility for the address."""
  visibility: UUID = null

  """Validity range for the org-unit."""
  validity: RAValidityInput!

  """User key of the address. If None, defaults to value"""
  user_key: String = null

  """The actual address value."""
  value: String = null

  """Type of the address."""
  address_type: UUID = null
}

"""Connects organisation units and employees"""
type Association {
  "The type of connection that the employee has to the organisation unit.\n\nExamples:\n* `\"Chairman\"`\n* `\"Leader\"`\n* `\"Employee\"`\n"
  association_type(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  "List of arbitrary classes.\n\nThe purpose of this field is ill-defined.\nIt is currently mainly used for (trade) union specification.\n"
  dynamic_class(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class @deprecated(reason: "Will be removed in a future version of GraphQL.\nCurrently no replacement is in place, but specialized fields will probably arive in the future.\n")

  "Marks associations with a trade union\n"
  trade_union(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  "Marks which association is primary.\n\nWhen exporting data from OS2mo to external systems, that only support a single engagement or associations, this field can be used to export the primary one.\nWhat primarity means is vaguely defined, but usually derived from workload or time-allocation.\n\nExamples  of user-keys:\n* `\"primary\"`\n* `\"non-primary\"`\n* `\"explicitly-primary\"`\n\nIt is a convention that at most one association for each employee is set as either `primary` or `explicitly-primary`.\nThis convention is in place as if more associations are primary, the entire purpose of the field breaks down.\nIn the future this convention may become an invariant.\n\nNote:\nThe calculate-primary integration can be used to automatically calculate and update primarity fields.\n"
  primary(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  "Associated employee.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  employee(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]! @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  "Associated person.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  person(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]!

  "Associated organisation unit.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  org_unit(
    filter: UuidsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [OrganisationUnit!]!

  "Optional subsitute if `employee` is unavailable.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  substitute(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]!

  "The position held by the employee in the organisation unit.\n\nExamples of user-keys:\n* `\"Payroll consultant\"`\n* `\"Office student\"`\n* `\"Jurist\"`\n"
  job_function(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  "The IT-user utilized by the employee when fulfilling the association responsibilities.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  it_user(
    filter: UuidsBoundITUserFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [ITUser!]!

  "The object type.\n\nAlways contains the string `association`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the entity"""
  uuid: UUID!

  "Short unique key.\n\nUsually set to be set to the key used in external systems.\n\nExamples:\n* `\"1462\"`\n* `\"XSIMP\"`\n"
  user_key: String!

  """UUID of the dynamically attached class."""
  dynamic_class_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `dynamic_class {uuid}` instead.\n")

  """UUID of the attached trade union."""
  trade_union_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `trade_union {uuid}` instead.\n")

  """UUID of the organisation unit related to the association."""
  org_unit_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `org_unit {uuid}` instead.\n")

  """UUID of the employee related to the association."""
  employee_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `employee {uuid}` instead.\n")

  """UUID of the association type."""
  association_type_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `association_type {uuid}` instead.\n")

  """UUID of the primary type of the association."""
  primary_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `primary {uuid}` instead.\n")

  """UUID of the substitute for the employee in the association."""
  substitute_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `subsitute {uuid}` instead.\n")

  """UUID of a job function class, only defined for 'IT associations."""
  job_function_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `job_function {uuid}` instead.\n")

  """UUID of an 'ITUser' model, only defined for 'IT associations."""
  it_user_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `it_user {uuid}` instead.\n")

  "Same as association_type, but with HACKs to enable validities.\n"
  association_type_validity: Class @deprecated(reason: "Should only be used to query association_types when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  """Validity of the association object."""
  validity: Validity!
}

input AssociationCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """Extra info or uuid."""
  user_key: String = null

  """Primary field of the association"""
  primary: UUID = null

  """Validity range for the org-unit."""
  validity: RAValidityInput!

  """Employee uuid."""
  person: UUID = null

  """Employee uuid."""
  employee: UUID = null @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  """Substitute uuid."""
  substitute: UUID = null

  """Trade union uuid."""
  trade_union: UUID = null

  """org-unit uuid."""
  org_unit: UUID!

  """Association type uuid."""
  association_type: UUID!
}

"""Association filter."""
input AssociationFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Employee filter limiting which entries are returned.\n"
  employee: EmployeeFilter = null

  "Employee UUID filter limiting which entries are returned.\n\n| `employees`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  employees: [UUID!] = null @deprecated(reason: "Replaced by the 'employee' filter")

  "Organisation Unit filter limiting which entries are returned.\n"
  org_unit: OrganisationUnitFilter = null

  "Organisational Unit UUID filter limiting which entries are returned.\n\n| `org_units`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  org_units: [UUID!] = null @deprecated(reason: "Replaced by the 'org_unit' filter")

  "Registration filter limiting which entries are returned.\n"
  registration: AssociationRegistrationFilter = null

  "Address type filter limiting which entries are returned.\n"
  association_type: ClassFilter = null

  "Association type UUID filter limiting which entries are returned.\n\n| `association_types`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  association_types: [UUID!] = null @deprecated(reason: "Replaced by the 'association_type' filter")

  "Association type user-key filter limiting which entries are returned.\n\n| `association_type_user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  association_type_user_keys: [String!] = null @deprecated(reason: "Replaced by the 'association_type' filter")

  "Query for either IT-Associations or \"normal\" Associations. `None` returns all.\n\nThis field is needed to replicate the functionality in the service API:\n`?it=1`\n"
  it_association: Boolean = null
}

"""Association registration filter."""
input AssociationRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type AssociationResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): Association

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [Association!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [Association!]!
}

"""Result page in cursor-based pagination."""
type AssociationResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [AssociationResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input AssociationTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID for the association we want to terminate."""
  uuid: UUID!
}

input AssociationUpdateInput {
  """UUID of the association we want to update."""
  uuid: UUID!

  """Extra info or uuid."""
  user_key: String = null

  """Primary field of the association"""
  primary: UUID = null

  """Validity range for the org-unit."""
  validity: RAValidityInput!

  """Employee uuid."""
  person: UUID = null

  """Employee uuid."""
  employee: UUID = null @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  """Substitute uuid."""
  substitute: UUID = null

  """Trade union uuid."""
  trade_union: UUID = null

  """org-unit uuid."""
  org_unit: UUID = null

  """Association type uuid."""
  association_type: UUID = null
}

"AuditLog entry.\n\nMostly useful for auditing purposes seeing when data-reads were done and by whom.\n"
type AuditLog {
  "UUID of the audit entry itself.\n"
  id: UUID!

  "When the read occured.\n\nExamples:\n* `\"1970-01-01T00:00:00.000000+00:00\"`\n* `\"2019-12-18T12:55:15.348614+00:00\"`\n"
  time: DateTime!

  "UUID of the actor (integration or user) who changed the data.\n\nNote:\nCurrently mostly returns `\"42c432e8-9c4a-11e6-9f62-873cf34a735f\"`.\nWill eventually contain for the UUID of the integration or user who mutated data, based on the JWT token.\n"
  actor: UUID!

  "Model of the modified entity.\n"
  model: AuditLogModel!

  "UUIDs of entities that were read.\n"
  uuids: [UUID!]!
}

"""Audit log filter."""
input AuditLogFilter {
  "ID filter limiting which entries are returned.\n\n| `ids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  ids: [UUID!] = null

  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "Filter audit events by their reading actor.\n\nCan be used to select all data read by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  "Filter audit events by their model type.\n\nCan be used to select all reads for a data type.\n\nCan be one of:\n* `\"AuditLog\"`\n* `\"Bruger\"`\n* `\"Facet\"`\n* `\"ItSystem\"`\n* `\"Klasse\"`\n* `\"Organisation\"`\n* `\"OrganisationEnhed\"`\n* `\"OrganisationFunktion\"`\n\n| `models`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  models: [AuditLogModel!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

enum AuditLogModel {
  AUDIT_LOG
  PERSON
  FACET
  IT_SYSTEM
  CLASS
  ORGANISATION @deprecated(reason: "The root organisation concept will be removed in a future version of OS2mo.")
  ORGANISATION_UNIT
  ORGANISATION_FUNCTION
}

"""Result page in cursor-based pagination."""
type AuditLogPaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [AuditLog!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

"Scalar implementing the danish national identification number / civil registration number.\n\nThe number is a unique identifier for a single individual, although individuals may go through several numbers over time.\n\nThe number is expected to have 10 digits, 6 digits defining a date, and a 4 digit serial number.\nThe number does not have to fulfill the modulo 11 checksum.\nIt does however (optionally) have to define a valid date.\nNo dash should be included to separate the date and serial number sections.\n\nFor further details refer to the Central Person Register (CPR) at:\n* https://cpr.dk/\n\nOr \"Bekendtgrelse af lov om Det Centrale Personregister\" (\"CPR-Loven\"):\n* https://www.retsinformation.dk/eli/lta/2017/646\n\nExamples:\n* `\"0106875049\"`\n* `\"0106878994\"`\n* `\"406568970\"`\n"
scalar CPR

"A value in the facet sample space.\n\nClasses can also be thought of as the value component of the facet/class key-value setup.\n"
type Class {
  "Parent class.\n\nAlmost always `null` as class hierarchies are rare.\nCurrently mostly used to describe (trade) union hierachies.\n\nThe inverse operation of `children`.\n"
  parent(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  "Class children.\n\nAlmost always an empty list as class hierarchies are rare.\nCurrently mostly used to describe (trade) union hierachies.\n\nThe inverse operation of `parent`.\n"
  children(
    filter: ParentsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Class!]!

  "Facet this class is defined under.\n\nExamples of user-keys:\n* `\"employee_address_type\"`\n* `\"primary_type\"`\n* `\"engagement_job_function\"`\n"
  facet(
    filter: UuidsBoundFacetFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Facet!

  "The IT-System associated with the class.\n\nThis is intended to be used for (IT) roles.\n"
  it_system(
    filter: UuidsBoundITSystemFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): ITSystem

  "Facet of this class's upmost parent.\n\nThe result of following `parent` until `parent` becomes `null`, then calling `facet`.\n\nAlmost always the same as `facet` as class hierarchies are rare.\nCurrently mostly used to describe (trade) union hierachies.\n"
  top_level_facet: Facet! @deprecated(reason: "Will be removed in a future version of GraphQL.\nWill either be replaced by client-side recursion, an ancestor field or a recursive schema directive.\nFor now client-side recursion is the preferred replacement.\n")

  "Full name of the class, exactly the same as `name`.\n"
  full_name: String! @deprecated(reason: "Will be removed in a future version of GraphQL.\nReturns exactly the same as `name`, use that instead.\n")

  "The object type.\n\nAlways contains the string `class`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the entity"""
  uuid: UUID!

  "Short unique key.\n\nUsually set to the `name` provided on object creation.\nMay also be set to the key used in external systems or a system-name.\n\nUsually also used as the machine \"value\" for the class.\n\nExamples:\n* `\"primary\"`\n* `\"PhoneEmployee\"`\n* `\"Jurist\"`\n* `\"X-418\"`\n"
  user_key: String!

  "Human readable name of the class.\n\nThis is the value that should be shown to users in UIs.\n\nExamples:\n* `\"Primary\"`\n* `\"Phone number\"`\n* `\"Jurist\"`\n* `\"Paragraph 11 Hire\"`\n"
  name: String!

  "Scope of the class.\n\nThe scope of the class describes the kind of values that can be contained when using the class.\nIt has different implications depending on the associated facet.\n\nBelow is a non-exhaustive list of scope values for a non-exhaustive list of facets:\n\nFacet `visibility`; scope controls visibility classes:\n* `\"PUBLIC\"`: The entity can be shared publicly.\n* `\"SECRET\"`: The entity should not be shared publicly.\n\nFacet `primary_type`; scope controls how primary the class is:\n* `\"0\"`: Not primary.\n* `\"3000\"`: Primary.\n* `\"5000\"`: Explicitly primary / override.\n\nA lot of facets; scope controls input-validation:\n* `\"TEXT\"`: The input can be any text string.\n* `\"PHONE\"`: The input must match OS2mo's phone number regex.\n* `\"PNUMBER\"`: The input must match OS2mo's p-number regex.\n* `\"EMAIL\"`: The input must match OS2mo's email regex.\n* `\"DAR\"`: The input must be a DAR UUID.\n"
  scope: String

  "Published state of the class object.\n\nWhether the class is published or not, aka. if it should be shown.\n\nExamples:\n* `\"Publiceret\"`\n* `\"IkkePubliceret\"`\n* `\"Normal\"`\n\nNote:\nReturn change may change to an enum in the future.\n\nMay eventually be superseeded by validities on classes.\n"
  published: String

  "Example usage.\n\nAlmost always `null`.\n"
  example: String @deprecated(reason: "Will be removed in a future version of GraphQL.\nThis field is almost never used, and serves no real purpose.\nMay be reintroduced in the future if the demand for it increases.\n")

  """UUID of the related facet."""
  facet_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `facet {uuid}` instead.\n")

  """UUID of the related organisation."""
  org_uuid: UUID! @deprecated(reason: "The root organisation concept will be removed in a future version of OS2mo.\n")

  """UUID of the employee related to the address."""
  parent_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `parent {uuid}` instead.\n")

  """The IT-System associated with the class."""
  it_system_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `it_system {uuid}` instead.\n")

  """Owner of class"""
  owner: UUID

  """Validity of the class."""
  validity: OpenValidity!
}

input ClassCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """Mo-class name."""
  name: String!

  """Extra info or uuid"""
  user_key: String!

  """UUID of the related facet."""
  facet_uuid: UUID!

  """Scope of the class."""
  scope: String = null

  """Published state of the class object."""
  published: String! = "Publiceret"

  """UUID of the parent class."""
  parent_uuid: UUID = null

  """Example usage."""
  example: String = null

  """Owner of class"""
  owner: UUID = null

  """Validity range for the class."""
  validity: ValidityInput!

  """UUID of the associated IT-system."""
  it_system_uuid: UUID = null
}

"""Class filter."""
input ClassFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Registration filter limiting which entries are returned.\n"
  registration: ClassRegistrationFilter = null

  "Facet filter limiting which entries are returned.\n"
  facet: FacetFilter = null

  "Facet UUID filter limiting which entries are returned.\n\n| `facets`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  facets: [UUID!] = null @deprecated(reason: "Replaced by the 'facet' filter")

  "Facet user-key filter limiting which entries are returned.\n\n| `facet_user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  facet_user_keys: [String!] = null @deprecated(reason: "Replaced by the 'facet' filter")

  "Parent filter limiting which entries are returned.\n"
  parent: ClassFilter = null

  "Parent UUID filter limiting which entries are returned.\n\n| `parents`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  parents: [UUID!] = null @deprecated(reason: "Replaced by the 'parent' filter")

  "Parent user-key filter limiting which entries are returned.\n\n| `parent_user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  parent_user_keys: [String!] = null @deprecated(reason: "Replaced by the 'parent' filter")

  "IT-System filter limiting which entries are returned.\n"
  it_system: ITSystemFilter = null

  "Owner filter limiting which entries are returned.\n"
  owner: ClassOwnerFilter = null

  "Scope filter limiting which entries are returned.\n\n| `scope`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  scope: [String!] = null
}

"""Class owner filter"""
input ClassOwnerFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Registration filter limiting which entries are returned.\n"
  registration: OrganisationUnitRegistrationFilter = null

  "Free text search.\n\nDoes best effort lookup to find entities matching the query string.\nNo quarantees are given w.r.t. the entries returned.\n"
  query: String

  "Name filter finding exact matches by name.\n\n| `names`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  names: [String!]

  "Select organisation units whose parent matches the given filter.\n\nSet to `None` to find root units.\nSet to `{}` to find non-root units.\n\nThis endpoint behaves to ancestor as child does to descendant.\n"
  parent: OrganisationUnitFilter

  "Parent UUID filter limiting which entries are returned.\n\n| `parents`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  parents: [UUID!] @deprecated(reason: "Replaced by the 'parent' filter")

  "Select organisation units whose children matches the given filter.\n\nSet to `None` to find leaf node units.\nSet to `{}` to find inner node units.\n\nThis endpoint behaves to descendant as parent does to ancestor.\n"
  child: OrganisationUnitFilter

  "Hierarchy filter limiting which entries are returned.\n\nFilter organisation units by their organisational hierarchy labels.\n\nCan be used to extract a subset of the organisational structure.\n\nExamples of user-keys:\n* `\"Line-management\"`\n* `\"Self-owned institution\"`\n* `\"Outside organisation\"`\n* `\"Hidden\"`\n\nNote:\nThe organisation-gatekeeper integration is one option to keep hierarchy labels up-to-date.\n"
  hierarchy: ClassFilter = null

  "Filter organisation units by their organisational hierarchy labels.\n\nCan be used to extract a subset of the organisational structure.\n\nExamples of user-keys:\n* `\"Line-management\"`\n* `\"Self-owned institution\"`\n* `\"Outside organisation\"`\n* `\"Hidden\"`\n\nNote:\nThe organisation-gatekeeper integration is one option to keep hierarchy labels up-to-date.\n\n| `hierarchies`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  hierarchies: [UUID!] = null @deprecated(reason: "Replaced by the 'hierarchy' filter")
  subtree: OrganisationUnitFilter @deprecated(reason: "Renamed to 'descendant'")

  "Select organisation units which have a descendant matching the given filter.\n\nNote that every node is its own descendant as per [CLRS] 12.2-6.\n\nGiven the following tree:\n```\nA\n B\n    C\n       D\n    E\n F\n```\nthe `descendant` filter behaves according to the following table:\n\n| Filter | Returned    |\n|--------|-------------|\n|      A | A           |\n|      B | A B         |\n|      C | A B C       |\n|      D | A B C D     |\n|      E | A B E       |\n|      F | A F         |\n"
  descendant: OrganisationUnitFilter

  "Select organisation units which have an ancestor matching the given filter.\n\nNote that every node is its own ancestor as per [CLRS] 12.2-6.\n\nGiven the following tree:\n```\nA\n B\n    C\n       D\n    E\n F\n```\nthe `ancestor` filter behaves according to the following table:\n\n| Filter | Returned    |\n|--------|-------------|\n|      A | A B C D E F |\n|      B | B C D E     |\n|      C | C D         |\n|      D | D           |\n|      E | E           |\n|      F | F           |\n"
  ancestor: OrganisationUnitFilter

  "Filter organisation units to only include matches pointed to by engagements.\n\nCan be used to find organisation units for certain engagements.\n"
  engagement: EngagementFilter = null

  "Include classes with `owner=None`.\n"
  include_none: Boolean! = false
}

"""Class registration filter."""
input ClassRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type ClassResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): Class

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [Class!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [Class!]!
}

"""Result page in cursor-based pagination."""
type ClassResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [ClassResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input ClassTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID for the class we want to terminate."""
  uuid: UUID!
}

input ClassUpdateInput {
  """UUID of the class to update."""
  uuid: UUID!

  """Mo-class name."""
  name: String!

  """Extra info or uuid"""
  user_key: String!

  """UUID of the related facet."""
  facet_uuid: UUID!

  """Scope of the class."""
  scope: String = null

  """Published state of the class object."""
  published: String! = "Publiceret"

  """UUID of the parent class."""
  parent_uuid: UUID = null

  """Example usage."""
  example: String = null

  """Owner of class"""
  owner: UUID = null

  """Validity range for the class."""
  validity: ValidityInput!

  """UUID of the associated IT-system."""
  it_system_uuid: UUID = null
}

"""A configuration setting."""
type Configuration {
  "The unique settings identifier.\n\nExamples:\n* `commit_tag`\n* `environment`\n* `confdb_show_roles`\n"
  key: String!

  "JSONified settings value.\n\nExamples:\n* `\"true\"`\n* `\"\\\"\\\"\"`\n* `\"null\"`\n* `\"[]\"`\n"
  jsonified_value: String!

  "Stringified settings value.\n\nExamples:\n* `\"True\"`\n* `\"\"`\n* `\"None\"`\n* `\"[]\"`\n"
  stringified_value: String!
}

"""Configuration filter."""
input ConfigurationFilter {
  "Key filter limiting which entries are returned.\n\n| `identifiers`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  identifiers: [String!] = null
}

"""Result page in cursor-based pagination."""
type ConfigurationPaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [Configuration!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

"Scalar implementing the cursor of cursor-based pagination.\n\nThe cursor is opaque by design abstracting away the underlying implementation details.\n\nExamples:\n* `\"Njk=\"`\n* `\"NDIw\"`\n* `\"MTMzNw==\"`\n\nNote:\n\nAs the cursor is to be considered opaque its implementation may change in the future.\nI.e. in the future it may be implemented as a simple integer or a complex object.\n\nThe caller should not concern themselves with the actual value contained within, but rather simply pass whatever is returned in the `cursor` argument to continue iteration.\n"
scalar Cursor

type DARAddress implements ResolvedAddress {
  value: String!
  description: String!
  road_code: Int!
  road_name: String!
  house_number: String!
  floor: String
  door: String
  zip_code: String!
  zip_code_name: String!
  municipality_code: String!
  longitude: Float!
  latitude: Float!
  name: String!
  href: String!
  streetmap_href: String
}

"""Date (isoformat)"""
scalar Date

"""Date with time (isoformat)"""
scalar DateTime

type DefaultAddress implements ResolvedAddress {
  value: String!
}

"""Employee/identity specific information"""
type Employee {
  "Engagements for the employee.\n\nMay be an empty list if the employee is not employeed.\n"
  engagements(
    filter: EmployeesBoundEngagementFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Engagement!]!

  "Managerial roles for the employee.\n\nUsually an empty list as most employees are not managers.\n"
  manager_roles(
    filter: EmployeesBoundManagerFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null

    "Whether to inherit managerial roles or not.\n\nIf managerial roles exist directly on this organisation unit, the flag does nothing and these managerial roles are returned.\nHowever if no managerial roles exist directly, and this flag is:\n* False: An empty list is returned.\n* True: The result from calling `managers` with `inherit=True` on the parent of this organistion unit is returned.\n\nCalling with `inherit=True` can help ensure that a manager is always found.\n"
    inherit: Boolean! = false
  ): [Manager!]!

  "Addresses for the employee.\n\nCommonly contain addresses such as, their:\n* Work location\n* Office number\n* Work phone number\n* Work email\n* Personal phone number\n* Personal email\n"
  addresses(
    filter: EmployeesBoundAddressFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Address!]!

  "Leaves of absence for the employee.\n\nUsually empty as most employees are not on leaves of absence.\n"
  leaves(
    filter: EmployeesBoundLeaveFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Leave!]!

  "Associations for the employee.\n\nMay be an empty list if the employee is not associated with projects, etc.\n"
  associations(
    filter: EmployeesBoundAssociationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Association!]!

  "IT accounts for the employee.\n\nMay be an empty list if the employee does not have any IT-access whatsoever.\n"
  itusers(
    filter: EmployeesBoundITUserFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [ITUser!]!

  """UUID of the entity"""
  uuid: UUID!

  "Short unique key.\n\nUsually set to be set to the key used in external systems.\n\nDefaults to the `uuid` generated on object creation.\n\nExamples:\n* `\"1462\"`\n* `\"XSIMP\"`\n"
  user_key: String!

  "The object type.\n\nAlways contains the string `employee`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """CPR number of the employee."""
  cpr_number: CPR

  """Full name of the employee"""
  name: String!

  """Given name of the employee."""
  given_name: String!

  """Full nickname of the employee"""
  nickname: String!

  """Given name part of nickname of the employee."""
  nickname_given_name: String

  "Same as engagements(), but with HACKs to enable validities.\n"
  engagements_validity: [Engagement!]! @deprecated(reason: "Should only be used to query engagements when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  "Same as addresses(), but with HACKs to enable validities.\n"
  addresses_validity: [Address!]! @deprecated(reason: "Should only be used to query addresses when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  "Same as associations(), but with HACKs to enable validities.\n"
  associations_validity: [Association!]! @deprecated(reason: "Should only be used to query associations when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  "Same as itusers(), but with HACKs to enable validities.\n"
  itusers_validity: [ITUser!]! @deprecated(reason: "Should only be used to query itusers when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  """CPR number of the employee."""
  cpr_no: CPR @deprecated(reason: "Use 'cpr_number' instead. Will be removed in a future version of OS2mo.")

  """Seniority of the employee."""
  seniority: Date

  """Given name of the employee."""
  givenname: String! @deprecated(reason: "Use 'given_name' instead. Will be removed in a future version of OS2mo.")

  """Surname of the employee."""
  surname: String!

  """Given name part of nickname of the employee."""
  nickname_givenname: String @deprecated(reason: "Use 'nickname_given_name' instead. Will be removed in a future version of OS2mo.")

  """Surname part of nickname of the employee."""
  nickname_surname: String

  """Validity of the employee."""
  validity: OpenValidity!
}

input EmployeeCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """
  Short, unique key for the employee (defaults to object UUID on creation).
  """
  user_key: String = null

  """Nickname givenname (firstname) of the employee."""
  nickname_given_name: String = null

  """Nickname surname (lastname) of the employee."""
  nickname_surname: String = null

  """New seniority value of the employee."""
  seniority: Date = null

  """Danish CPR number of the employee."""
  cpr_number: CPR = null

  """Givenname (firstname) of the employee."""
  given_name: String!

  """Surname (lastname) of the employee."""
  surname: String!
}

"""Employee filter."""
input EmployeeFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Registration filter limiting which entries are returned.\n"
  registration: EmployeeRegistrationFilter = null

  "Free text search.\n\nDoes best effort lookup to find entities matching the query string.\nNo quarantees are given w.r.t. the entries returned.\n"
  query: String

  "CPR number filter limiting which entries are returned.\n\n| `cpr_numbers`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  cpr_numbers: [CPR!] = null
}

"""Employee registration filter."""
input EmployeeRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type EmployeeResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): Employee

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [Employee!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [Employee!]!
}

"""Result page in cursor-based pagination."""
type EmployeeResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [EmployeeResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input EmployeeTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID for the employee we want to terminate."""
  uuid: UUID!

  """Mark related manager functions as vacated"""
  vacate: Boolean! = false
}

input EmployeeUpdateInput {
  """UUID of the employee to be updated."""
  uuid: UUID!

  """
  Short, unique key for the employee (defaults to object UUID on creation).
  """
  user_key: String = null

  """Nickname givenname (firstname) of the employee."""
  nickname_given_name: String = null

  """Nickname surname (lastname) of the employee."""
  nickname_surname: String = null

  """New seniority value of the employee."""
  seniority: Date = null

  """Danish CPR number of the employee."""
  cpr_number: CPR = null

  """New first-name value of the employee nickname."""
  given_name: String = null

  """New last-name value of the employee nickname."""
  surname: String = null

  """Validity range for the change."""
  validity: RAValidityInput!
}

input EmployeesBoundAddressFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  employee: EmployeeFilter = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: AddressRegistrationFilter = null
  address_type: ClassFilter = null
  address_types: [UUID!] = null
  address_type_user_keys: [String!] = null
  engagement: EngagementFilter = null
  engagements: [UUID!] = null
  ituser: ITUserFilter = null
  visibility: ClassFilter = null
}

input EmployeesBoundAssociationFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  employee: EmployeeFilter = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: AssociationRegistrationFilter = null
  association_type: ClassFilter = null
  association_types: [UUID!] = null
  association_type_user_keys: [String!] = null
  it_association: Boolean = null
}

input EmployeesBoundEngagementFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  employee: EmployeeFilter = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: EngagementRegistrationFilter = null
  job_function: ClassFilter = null
  engagement_type: ClassFilter = null
}

input EmployeesBoundITUserFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  employee: EmployeeFilter = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: ITUserRegistrationFilter = null
  itsystem: ITSystemFilter = null
  itsystem_uuids: [UUID!] = null
  engagement: EngagementFilter = null
  external_ids: [String!] = null
}

input EmployeesBoundLeaveFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  employee: EmployeeFilter = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: LeaveRegistrationFilter = null
}

input EmployeesBoundManagerFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  employee: EmployeeFilter = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: ManagerRegistrationFilter = null
  responsibility: ClassFilter = null
}

"""Employee engagement in an organisation unit"""
type Engagement {
  "Describes the employee's affiliation to an organisation unit\n\nExamples:\n* `\"Employed\"`\n* `\"Social worker\"`\n* `\"Employee (hourly wage)\"`\n"
  engagement_type(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class!

  "Describes the position of the employee in the organisation unit\n\nExamples:\n* `\"Payroll consultant\"`\n* `\"Office student\"`\n* `\"Jurist\"`\n"
  job_function(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class!

  "Marks which engagement is primary.\n\nWhen exporting data from OS2mo to external systems, that only support a single engagement or associations, this field can be used to export the primary one.\nWhat primarity means is vaguely defined, but usually derived from workload or time-allocation.\n\nExamples  of user-keys:\n* `\"primary\"`\n* `\"non-primary\"`\n* `\"explicitly-primary\"`\n\nIt is a convention that at most one engagement for each employee is set as either `primary` or `explicitly-primary`.\nThis convention is in place as if more engagements are primary, the entire purpose of the field breaks down.\nIn the future this convention may become an invariant.\n\nNote:\nThe calculate-primary integration can be used to automatically calculate and update primarity fields.\n"
  primary(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  """Related leave"""
  leave(
    filter: UuidsBoundLeaveFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Leave

  "The employee fulfilling the engagement.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  employee(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]! @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  "The person fulfilling the engagement.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  person(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]!

  "The organisation unit where the engagement is being fulfilled.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  org_unit(
    filter: UuidsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [OrganisationUnit!]!

  """UUID of the entity"""
  uuid: UUID!

  "Short unique key.\n\nUsually set to the `id` used in external systems.\n\nExamples:\n* `\"11009\"`\n* `\"02782\"`\n"
  user_key: String!

  "Whether this engagement is the primary engagement.\n\nChecks if the `primary` field contains either a class with user-key: `\"primary\"` or `\"explicitly-primary\"`.\n"
  is_primary: Boolean!

  "The object type.\n\nAlways contains the string `engagement`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the engagement type class."""
  engagement_type_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `engagement_type {uuid}` instead.\n")

  """UUID of the employee related to the engagement."""
  employee_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `employee {uuid}` instead.\n")

  """UUID of the organisation unit related to the engagement."""
  org_unit_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `org_unit {uuid}` instead.\n")

  """UUID of the job function class."""
  job_function_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `job_function {uuid}` instead.\n")

  """UUID of the leave related to the engagement."""
  leave_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `leave {uuid}` instead.\n")

  """UUID of the primary klasse of the engagement."""
  primary_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `primary {uuid}` instead.\n")

  "Same as engagement_type, but with HACKs to enable validities.\n"
  engagement_type_validity: Class @deprecated(reason: "Should only be used to query engagement_type when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  """Validity of the engagement object."""
  validity: Validity!

  """
  Indication of contribution to the collection of engagements for the given employee.
  """
  fraction: Int

  """Optional extra information."""
  extension_1: String

  """Optional extra information."""
  extension_2: String

  """Optional extra information."""
  extension_3: String

  """Optional extra information."""
  extension_4: String

  """Optional extra information."""
  extension_5: String

  """Optional extra information."""
  extension_6: String

  """Optional extra information."""
  extension_7: String

  """Optional extra information."""
  extension_8: String

  """Optional extra information."""
  extension_9: String

  """Optional extra information."""
  extension_10: String
}

input EngagementCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """Name or UUID of the related engagement."""
  user_key: String = null

  """Primary field of the engagement"""
  primary: UUID = null

  """Validity of the engagement object."""
  validity: RAValidityInput!

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_1: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_2: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_3: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_4: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_5: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_6: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_7: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_8: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_9: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_10: String = null

  """UUID of the related employee."""
  employee: UUID = null @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  """UUID of the related employee."""
  person: UUID = null

  """The related org-unit object."""
  org_unit: UUID!
  engagement_type: UUID!
  job_function: UUID!
}

"""Engagement filter."""
input EngagementFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Employee filter limiting which entries are returned.\n"
  employee: EmployeeFilter = null

  "Employee UUID filter limiting which entries are returned.\n\n| `employees`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  employees: [UUID!] = null @deprecated(reason: "Replaced by the 'employee' filter")

  "Organisation Unit filter limiting which entries are returned.\n"
  org_unit: OrganisationUnitFilter = null

  "Organisational Unit UUID filter limiting which entries are returned.\n\n| `org_units`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  org_units: [UUID!] = null @deprecated(reason: "Replaced by the 'org_unit' filter")

  "Registration filter limiting which entries are returned.\n"
  registration: EngagementRegistrationFilter = null

  "Job function filter limiting which entries are returned.\n"
  job_function: ClassFilter = null

  "Engagement type filter limiting which entries are returned.\n"
  engagement_type: ClassFilter = null
}

"""Engagement registration filter."""
input EngagementRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type EngagementResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): Engagement

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [Engagement!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [Engagement!]!
}

"""Result page in cursor-based pagination."""
type EngagementResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [EngagementResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input EngagementTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID for the engagement we want to terminate."""
  uuid: UUID!
}

input EngagementUpdateInput {
  """UUID of the Engagement you want to update."""
  uuid: UUID!

  """Name or UUID of the related engagement."""
  user_key: String = null

  """Primary field of the engagement"""
  primary: UUID = null

  """Validity of the engagement object."""
  validity: RAValidityInput!

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_1: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_2: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_3: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_4: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_5: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_6: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_7: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_8: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_9: String = null

  "Arbitrary value extension fields.\n\nA collection of field for storing arbitrary extra data.\nCan be used for extraordinary occasions when no standardized field to model the data exists.\n\n"
  extension_10: String = null

  """UUID of the related employee."""
  employee: UUID = null @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  """UUID of the related employee."""
  person: UUID = null

  """The related org-unit object."""
  org_unit: UUID = null

  """UUID of the engagement type."""
  engagement_type: UUID = null

  """UUID of the job function."""
  job_function: UUID = null
}

"""The key component of the class/facet choice setup"""
type Facet {
  """Associated classes"""
  classes(
    filter: FacetsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Class!]!

  "Parent facet.\n\nAlmost always `null` as facet hierarchies are rare.\nCurrently mostly used to describe (trade) union hierachies.\n\nThe inverse operation of `children`.\n"
  parent(
    filter: UuidsBoundFacetFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Facet

  "Facet children.\n\nAlmost always an empty list as facet hierarchies are rare.\nCurrently mostly used to describe (trade) union hierachies.\n\nThe inverse operation of `parent`.\n"
  children(
    filter: ParentsBoundFacetFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Facet!]!

  "The object type.\n\nAlways contains the string `facet`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the entity"""
  uuid: UUID!

  "Published state of the facet object.\n\nWhether the facet is published or not, aka. if it should be shown.\n\nExamples:\n* `\"Publiceret\"`\n* `\"IkkePubliceret\"`\n* `\"Normal\"`\n\nNote:\nReturn change may change to an enum in the future.\n\nMay eventually be superseeded by validities on facets.\n"
  published: String

  """UUID of the related organisation."""
  org_uuid: UUID! @deprecated(reason: "The root organisation concept will be removed in a future version of OS2mo.\n")

  """UUID of the parent facet."""
  parent_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `parent {uuid}` instead.\n")

  "Description of the facet object.\n\nAlmost always `\"\"`.\n"
  description: String @deprecated(reason: "Will be removed in a future version of GraphQL.\nThis field is almost never used, and serves no real purpose.\nMay be reintroduced in the future if the demand for it increases.\n")

  """Short, unique key."""
  user_key: String!

  """Validity of the facet."""
  validity: OpenValidity!
}

input FacetCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """Facet name."""
  user_key: String!

  """Published state of the facet object."""
  published: String! = "Publiceret"

  """Validity range for the facet. Default to ['-infinity', 'infinity']"""
  validity: ValidityInput!
}

"""Facet filter."""
input FacetFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Registration filter limiting which entries are returned.\n"
  registration: FacetRegistrationFilter = null

  "Parent filter limiting which entries are returned.\n"
  parent: FacetFilter = null

  "Parent UUID filter limiting which entries are returned.\n\n| `parents`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  parents: [UUID!] = null @deprecated(reason: "Replaced by the 'parent' filter")

  "Parent user-key filter limiting which entries are returned.\n\n| `parent_user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  parent_user_keys: [String!] = null @deprecated(reason: "Replaced by the 'parent' filter")
}

"""Facet registration filter."""
input FacetRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type FacetResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): Facet

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [Facet!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [Facet!]!
}

"""Result page in cursor-based pagination."""
type FacetResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [FacetResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input FacetTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID for the facet we want to terminate."""
  uuid: UUID!
}

input FacetUpdateInput {
  """UUID of the facet to update."""
  uuid: UUID!

  """Facet name."""
  user_key: String!

  """Published state of the facet object."""
  published: String! = "Publiceret"

  """Validity range for the facet. Default to ['-infinity', 'infinity']"""
  validity: ValidityInput!
}

input FacetsBoundClassFilter {
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: ClassRegistrationFilter = null
  facet: FacetFilter = null
  facet_user_keys: [String!] = null
  parent: ClassFilter = null
  parents: [UUID!] = null
  parent_user_keys: [String!] = null
  it_system: ITSystemFilter = null
  owner: ClassOwnerFilter = null
  scope: [String!] = null
}

"""A stored file available for download."""
type File {
  "The store the file is in.\n\nThe FileStore type lists all possible enum values.\n"
  file_store: FileStore!

  "Name of the file.\n\nExamples:\n* `\"report.odt\"`\n* `\"result.csv\"`\n"
  file_name: String!

  "The textual contents of the file.\n\nExamples:\n* A csv-file:\n```\nYear,Model,Make\n1997,Ford,E350\n2000,Mercury,Cougar\n...\n```\n* A textual report:\n```\nStatus of this Memo\n\nThis document specifies an Internet standards track\n...\n```\n\nNote:\nThis should only be used for text files formats such as `.txt` or `.csv`.\nFor binary formats please use `base64_contents` instead.\n"
  text_contents: String!

  "The base64 encoded contents of the file.\n\nExamples:\n* A text file:\n```\nTW96aWxsYSBQdWJsaWMgTGljZW5zZSBWZXJzaW9uIDIuMAo\n...\n```\n* A binary file:\n```\nf0VMRgIBAQAAAAAAAAAAAAIAPgABAAAAoF5GAAAA\n...\n```\n\nNote:\nWhile this works for binary and text files alike, it may be preferable to use `text_contents` for text files.\n"
  base64_contents: String!
}

"""File filter."""
input FileFilter {
  """File Store enum deciding which file-store to fetch files from."""
  file_store: FileStore!

  "Filename filter limiting which entries are returned.\n\n| `file_names`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  file_names: [String!] = null
}

"""Result page in cursor-based pagination."""
type FilePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [File!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

"Enum for all the supported file stores.\n\nFile stores can be thought of a separate folders or drives in desktop computing.\n"
enum FileStore {
  "The exports file store.\n\nUsed to hold files uploaded by export jobs.\n"
  EXPORTS

  "The insights file store.\n\nUsed to hold data-files supporting the insights functionality in OS2mo.\n"
  INSIGHTS
}

"""Status on whether a specific subsystem is working"""
type Health {
  "Healthcheck identifier.\n\nExamples:\n* `\"dataset\"`\n* `\"dar\"`\n* `\"amqp\"`\n"
  identifier: String!

  "Healthcheck status.\n\nReturns:\n* `true` if the healthcheck passed\n* `false` if the healthcheck failed\n* `null` if the healthcheck is irrelevant (submodule not loaded, etc)\n\nNote:\nQuerying the healthcheck status executes the underlying healthcheck directly.\nExcessively querying this endpoint may have performance implications.\n"
  status: Boolean
}

"""Health filter."""
input HealthFilter {
  "Healthcheck identifiers filter limiting which entries are returned.\n\n| `identifiers`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  identifiers: [String!] = null
}

"""Result page in cursor-based pagination."""
type HealthPaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [Health!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input ITAssociationCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """Extra info or uuid."""
  user_key: String = null

  """Primary field of the association"""
  primary: UUID = null

  """Validity range for the org-unit."""
  validity: RAValidityInput!

  """org-unit uuid."""
  org_unit: UUID!

  """UUID of the employee"""
  person: UUID!

  """IT-user UUID"""
  it_user: UUID!

  """Job function UUID"""
  job_function: UUID!
}

input ITAssociationTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID for the ITAssociation we want to terminate."""
  uuid: UUID!
}

input ITAssociationUpdateInput {
  """UUID of the ITAssociation you want to update."""
  uuid: UUID!

  """Extra info or uuid."""
  user_key: String = null

  """Primary field of the association"""
  primary: UUID = null

  """Validity range for the org-unit."""
  validity: RAValidityInput!

  """org-unit uuid."""
  org_unit: UUID = null

  """IT-user UUID"""
  it_user: UUID = null

  """Job function UUID"""
  job_function: UUID = null
}

"""Systems that IT users are connected to"""
type ITSystem {
  "The object type.\n\nAlways contains the string `itsystem`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the entity"""
  uuid: UUID!

  "Human readable name of the itsystem.\n\nThis is the value that should be shown to users in UIs.\n\nExamples:\n* `\"SAP\"`\n* `\"Active Directory\"`\n* `\"SD UUID\"`\n"
  name: String!

  "Short unique key.\n\nUsually set to be set to the key used in external systems.\n\nExamples:\n* `\"sap_user_uuid\"`\n* `\"ad_guid\"`\n* `\"sd_employee_uuid\"`\n"
  user_key: String!

  """The ITSystem type."""
  system_type: String

  """Validity of the IT system object."""
  validity: OpenValidity!
}

input ITSystemCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null
  user_key: String!
  name: String!

  """Validity range for the itsystem"""
  validity: RAOpenValidityInput!
}

"""IT system filter."""
input ITSystemFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Registration filter limiting which entries are returned.\n"
  registration: ITSystemRegistrationFilter = null
}

"""ITSystem registration filter."""
input ITSystemRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type ITSystemResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): ITSystem

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [ITSystem!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [ITSystem!]!
}

"""Result page in cursor-based pagination."""
type ITSystemResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [ITSystemResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input ITSystemTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID for the it-system we want to terminate."""
  uuid: UUID!
}

input ITSystemUpdateInput {
  """UUID for the it-system we want to edit."""
  uuid: UUID!
  user_key: String!
  name: String!

  """Validity range for the itsystem"""
  validity: RAOpenValidityInput!
}

"User information related to IT systems.\n\nThis is commonly used to map out IT accounts or IT service accounts.\nIt is however also used to hold IT system specific identifiers for correlation purposes.\n"
type ITUser {
  "Employee using the IT account.\n\nNote:\nThis field is mutually exclusive with the `org_unit` field.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  employee(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!] @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  "Person using the IT account.\n\nNote:\nThis field is mutually exclusive with the `org_unit` field.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  person(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]

  "Organisation unit using the IT account.\n\nThis is mostly set for service accounts.\n\nNote:\nThis field is mutually exclusive with the `org_unit` field.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  org_unit(
    filter: UuidsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [OrganisationUnit!]

  "Engagement scoping of the account.\n\nA person may have multiple IT accounts with each account being relevant for only a single engagement.\nThis field allows scoping IT accounts such that it is obvious which engagement has given which it-access.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  engagement(
    filter: UuidsBoundEngagementFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Engagement!]

  "Addresses connected with the IT-user.\n\nCommonly contain addresses such as:\n* Email\n* AD GUID\n* FK-org UUID\n"
  addresses(
    filter: ItuserBoundAddressFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Address!]!

  "ITSystem this account is for.\n"
  itsystem(
    filter: UuidsBoundITSystemFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): ITSystem!

  """Rolebindings this IT User has in the connected IT system."""
  rolebindings(
    filter: ItuserBoundRoleBindingFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [RoleBinding!]!

  "Marks which IT account is primary.\n\nWhen exporting data from OS2mo to external systems, that only support a single IT account, this field can be used to export the primary one.\nWhat primarity means is vaguely defined, but usually derived from workload or time-allocation.\n\nExamples  of user-keys:\n* `\"primary\"`\n* `\"non-primary\"`\n* `\"explicitly-primary\"`\n\nIt is a convention that at most one IT account for each employee / employee+engagement is set as either `primary` or `explicitly-primary`.\nThis convention is in place as if more IT accounts are primary, the entire purpose of the field breaks down.\nIn the future this convention may become an invariant.\n"
  primary(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  """UUID of the entity"""
  uuid: UUID!

  "Short unique key.\n\nUsually set to the key used in external systems.\n\nExamples:\n* `\"KarK\"`\n* `\"AnkS\"`\n* `\"XSIMP\"`\n* `\"04184cb6-a5de-47e6-8a08-03cae9ee4c54\"`\n"
  user_key: String!

  """ID of the user account in the external system."""
  external_id: String

  "The object type.\n\nAlways contains the string `it`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the ITSystem related to the user."""
  itsystem_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `itsystem {uuid}` instead.\n")

  """UUID of the employee related to the user."""
  employee_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `employee {uuid}` instead.\n")

  """UUID of the organisation unit related to the user."""
  org_unit_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `org_unit {uuid}` instead.\n")

  """UUID of the engagement related to the user."""
  engagement_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `engagement {uuid}` instead.\n")

  """UUID of the primary klasse of the user."""
  primary_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `primary {uuid}` instead.\n")

  "Same as itsystem, but with HACKs to enable validities.\n"
  itsystem_validity: ITSystem! @deprecated(reason: "Should only be used to query itsystem when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  """Validity of the IT user object."""
  validity: Validity!
}

input ITUserCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """ID of the user account in the external system."""
  external_id: String = null

  """Primary field of the IT user object"""
  primary: UUID = null

  """Reference to the employee for the IT user (if any)."""
  person: UUID = null

  """Reference to the organisation unit of the IT user (if any)."""
  org_unit: UUID = null

  """Reference to the engagement of the IT user (if any)."""
  engagement: UUID = null

  """Validity of the created IT user object."""
  validity: RAValidityInput!

  """The IT user account name."""
  user_key: String!

  """Reference to the IT system for the IT user."""
  itsystem: UUID!

  """Note associated with the creation of this IT user."""
  note: String = null
}

"""IT user filter."""
input ITUserFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Employee filter limiting which entries are returned.\n"
  employee: EmployeeFilter = null

  "Employee UUID filter limiting which entries are returned.\n\n| `employees`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  employees: [UUID!] = null @deprecated(reason: "Replaced by the 'employee' filter")

  "Organisation Unit filter limiting which entries are returned.\n"
  org_unit: OrganisationUnitFilter = null

  "Organisational Unit UUID filter limiting which entries are returned.\n\n| `org_units`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  org_units: [UUID!] = null @deprecated(reason: "Replaced by the 'org_unit' filter")

  "Registration filter limiting which entries are returned.\n"
  registration: ITUserRegistrationFilter = null

  "ITSystem filter limiting which entries are returned.\n"
  itsystem: ITSystemFilter = null

  "Only return IT users of ITSystem with these UUIDs filter limiting which entries are returned.\n\n| `itsystem_uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  itsystem_uuids: [UUID!] = null @deprecated(reason: "Replaced by the 'itsystem' filter")

  "Engagement filter limiting which entries are returned.\n"
  engagement: EngagementFilter = null

  "Only return IT users with this `external_id` filter limiting which entries are returned.\n\n| `external_id`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  external_ids: [String!] = null
}

"""ITUser registration filter."""
input ITUserRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type ITUserResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): ITUser

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [ITUser!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [ITUser!]!
}

"""Result page in cursor-based pagination."""
type ITUserResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [ITUserResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input ITUserTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID for the it-user we want to terminate."""
  uuid: UUID!
}

input ITUserUpdateInput {
  """UUID of the IT-user you want to update."""
  uuid: UUID!

  """ID of the user account in the external system."""
  external_id: String = null

  """Primary field of the IT user object"""
  primary: UUID = null

  """Reference to the employee for the IT user (if any)."""
  person: UUID = null

  """Reference to the organisation unit of the IT user (if any)."""
  org_unit: UUID = null

  """Reference to the engagement of the IT user (if any)."""
  engagement: UUID = null

  """Validity of the created IT user object."""
  validity: RAValidityInput!

  """The IT user account name."""
  user_key: String = null

  """Reference to the IT system for the IT user."""
  itsystem: UUID = null

  """Note associated with the update of this IT user."""
  note: String = null
}

input ItuserBoundAddressFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  employee: EmployeeFilter = null
  employees: [UUID!] = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: AddressRegistrationFilter = null
  address_type: ClassFilter = null
  address_types: [UUID!] = null
  address_type_user_keys: [String!] = null
  engagement: EngagementFilter = null
  engagements: [UUID!] = null
  visibility: ClassFilter = null
}

input ItuserBoundRoleBindingFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: RoleRegistrationFilter = null
}

"KLE responsibility mapping.\n\nKLE stands for \"Kommunernes Landsforenings Emnesystematik\" which is a municipality taxonomy for mapping out municipality tasks.\n\nIn OS2mo KLE responsibilities can be mapped to organisation units to signify that a given organisational unit operates within certain municipality tasks.\nAdding KLE responsibilities to organisational units can help out with regards to GDPR by identifying which organisational units operate with sensitive tasks.\n\nThe KLE numbers themselves are dot seperated structured numbers alike this:\n* `\"00.75.00\"`: General data exchanges\n* `\"21.02.05\"`: Library study cafes\n* `\"32.15.08\"`: Alimony\n\nThe first number specifies the main-group, such as:\n* `\"00\"`: Municipality operations (Kommunens styrelse)\n* `\"21\"`: Libraries\n* `\"31\"`: Monetary benefits\n\nThe second number specifies the group, such as (for libraries):\n* `\"02\"`: On-site usage\n* `\"05\"`: AV Materials\n* `\"20\"`: Online services\n\nThe third and final number specifies the topic, such as (for library on-site usage):\n* `\"00\"`: General usage\n* `\"05\"`: Study cafes\n* `\"10\"`: Study centers\n\nSome KLE ranges are pre-reserved by The National Association of Municipalities (Kommunernes Landsforenings), however outside of these pre-reserved ranges municipalies are allowed to add their own local numbers.\nSpecifically no main-groups can be added, only groups and topics, both above 79.\n\nFor more details see: https://www.kle-online.dk\n"
type KLE {
  "The KLE number specifies the responsibility.\n\nFor more details read the `KLE` description.\n"
  kle_number(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Class!]!

  "KLE Aspects.\n\nThe KLE aspect describes the kind of relationship the organisation unit has with the responsibility given by the KLE number.\n\nExamples of user-keys:\n* `\"Insight\"`\n* `\"Executive\"`\n* `\"Responsible\"`\n"
  kle_aspects(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Class!]!

  "The organisation unit the responsibility is mapped to.\n"
  org_unit(
    filter: UuidsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [OrganisationUnit!]!

  "The object type.\n\nAlways contains the string `kle`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the entity"""
  uuid: UUID!

  "Short unique key.\n\nUsually set to be set to the kle number itself.\n\nExamples:\n* `\"00.75.00\"`\n* `\"21.02.05\"`\n* `\"32.15.08\"`\n"
  user_key: String!

  """UUID of the KLE number."""
  kle_number_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `kle_number {uuid}` instead.\n")

  """List of UUIDs of the KLE aspect."""
  kle_aspect_uuids: [UUID!]! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `kle_aspects {uuid}` instead.\n")

  """UUID of the organisation unit related to the KLE."""
  org_unit_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `org_unit {uuid}` instead.\n")

  """Validity of the kle object."""
  validity: Validity!
}

input KLECreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """Extra info or uuid."""
  user_key: String = null

  """UUID of the organisation unit of the KLE."""
  org_unit: UUID!

  """List of UUIDs of the KLE aspects."""
  kle_aspects: [UUID!]!

  """UUID of the KLE number."""
  kle_number: UUID!

  """Validity range for the KLE."""
  validity: RAValidityInput!
}

"""KLE filter."""
input KLEFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Organisation Unit filter limiting which entries are returned.\n"
  org_unit: OrganisationUnitFilter = null

  "Organisational Unit UUID filter limiting which entries are returned.\n\n| `org_units`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  org_units: [UUID!] = null @deprecated(reason: "Replaced by the 'org_unit' filter")

  "Registration filter limiting which entries are returned.\n"
  registration: KLERegistrationFilter = null
}

"""KLE registration filter."""
input KLERegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type KLEResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): KLE

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [KLE!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [KLE!]!
}

"""Result page in cursor-based pagination."""
type KLEResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [KLEResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input KLETerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID of the KLE annotation we want to terminate."""
  uuid: UUID!
}

input KLEUpdateInput {
  """UUID of the KLE annotation to be updated."""
  uuid: UUID!

  """Extra info or uuid."""
  user_key: String = null

  """UUID of the KLE number."""
  kle_number: UUID = null

  """UUID of the kle_aspects."""
  kle_aspects: [UUID!] = null

  """UUID of the KLE's organisation unit to be updated."""
  org_unit: UUID = null

  """Validity range for the KLE to be updated."""
  validity: RAValidityInput!
}

"A leave of absence for an employee.\n\nCan be everything from a pregnancy or maternity leave to a furlough or a garden leave.\nThe `leave_type` can be used to determine the type of leave in question.\n"
type Leave {
  "The kind of leave of absence.\n\nExamples:\n* `\"Maternity leave\"`\n* `\"Parental leave\"`\n* `\"Furlough\"`\n* `\"Garden Leave\"`\n"
  leave_type(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class!

  "The absent employee.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  employee(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]! @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  "The absent person.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  person(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]!

  "The engagement the employee is absent from.\n"
  engagement(
    filter: UuidsBoundEngagementFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Engagement!

  "The object type.\n\nAlways contains the string `leave`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the entity"""
  uuid: UUID!

  """UUID of the KLE number."""
  leave_type_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `leave_type {uuid}` instead.\n")

  """UUID of the KLE number."""
  employee_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `employee {uuid}` instead.\n")

  """UUID of the KLE number."""
  engagement_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `engagement {uuid}` instead.\n")

  """Short, unique key. Defaults to object UUID."""
  user_key: String!

  """Validity of the leave object."""
  validity: Validity!
}

input LeaveCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """Extra info or uuid."""
  user_key: String = null

  """UUID of the person."""
  person: UUID!

  """UUID of the related engagement."""
  engagement: UUID!

  """UUID of the leave type"""
  leave_type: UUID!

  """Validity range for the leave."""
  validity: RAValidityInput!
}

"""Leave filter."""
input LeaveFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Employee filter limiting which entries are returned.\n"
  employee: EmployeeFilter = null

  "Employee UUID filter limiting which entries are returned.\n\n| `employees`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  employees: [UUID!] = null @deprecated(reason: "Replaced by the 'employee' filter")

  "Organisation Unit filter limiting which entries are returned.\n"
  org_unit: OrganisationUnitFilter = null

  "Organisational Unit UUID filter limiting which entries are returned.\n\n| `org_units`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  org_units: [UUID!] = null @deprecated(reason: "Replaced by the 'org_unit' filter")

  "Registration filter limiting which entries are returned.\n"
  registration: LeaveRegistrationFilter = null
}

"""Leave registration filter."""
input LeaveRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type LeaveResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): Leave

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [Leave!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [Leave!]!
}

"""Result page in cursor-based pagination."""
type LeaveResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [LeaveResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input LeaveTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID of the leave we want to terminate."""
  uuid: UUID!
}

input LeaveUpdateInput {
  """UUID of the leave."""
  uuid: UUID!

  """Extra info or uuid."""
  user_key: String = null

  """UUID of the person."""
  person: UUID = null

  """UUID of the related engagement."""
  engagement: UUID = null

  """UUID of the leave type"""
  leave_type: UUID = null

  """Validity range for the leave."""
  validity: RAValidityInput!
}

"Managers of organisation units and their connected identities.\n"
type Manager {
  "Title of the manager.\n\nExamples:\n* `\"Director\"`\n* `\"Area manager\"`\n* `\"Center manager\"`\n"
  manager_type(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class!

  "Hierarchical level of the manager.\n\nExamples:\n* `\"Level 1\"`\n* `\"Level 2\"`\n* `\"Level 3\"`\n"
  manager_level(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class!

  "Responsibilities that the manager takes care of.\n\nExamples:\n* `[\"Responsible for buildings and areas\"]`\n* `[\"Responsible for buildings and areas\", \"Staff: Sick leave\"]`\n* `[]`\n"
  responsibilities(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Class!]!

  "Employee fulfilling the managerial position.\n\nMay be empty in which case the managerial position is unfilfilled (vacant).\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  employee(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!] @deprecated(reason: "Use 'person' instead. Will be removed in a future version of OS2mo.")

  "Person fulfilling the managerial position.\n\nMay be empty in which case the managerial position is unfilfilled (vacant).\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  person(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]

  "Organisation unit being managed.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  org_unit(
    filter: UuidsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [OrganisationUnit!]!

  "The object type.\n\nAlways contains the string `manager`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the entity"""
  uuid: UUID!

  """UUID of the organisation unit related to the manager."""
  org_unit_uuid: UUID! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `org_unit {uuid}` instead.\n")

  """UUID of the employee related to the manager."""
  employee_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `employee {uuid}` instead.\n")

  """UUID of the manager type."""
  manager_type_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `manager_type {uuid}` instead.\n")

  """UUID of the manager level."""
  manager_level_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `manager_level {uuid}` instead.\n")

  """List of UUID's of the responsibilities."""
  responsibility_uuids: [UUID!] @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `responsibilities {uuid}` instead.\n")

  """Short, unique key. Defaults to object UUID."""
  user_key: String!

  """Validity of the manager object."""
  validity: Validity!
}

input ManagerCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """Extra info or uuid."""
  user_key: String = null

  """UUID of the manager as person."""
  person: UUID = null

  """UUID of the managers responsibilities."""
  responsibility: [UUID!]!

  """UUID of the managers organisation unit."""
  org_unit: UUID!

  """UUID of the managers level."""
  manager_level: UUID!

  """UUID of the managers type.."""
  manager_type: UUID!

  """Validity range for the manager."""
  validity: RAValidityInput!
}

"""Manager filter."""
input ManagerFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Employee filter limiting which entries are returned.\n"
  employee: EmployeeFilter = null

  "Employee UUID filter limiting which entries are returned.\n\n| `employees`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  employees: [UUID!] = null @deprecated(reason: "Replaced by the 'employee' filter")

  "Organisation Unit filter limiting which entries are returned.\n"
  org_unit: OrganisationUnitFilter = null

  "Organisational Unit UUID filter limiting which entries are returned.\n\n| `org_units`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  org_units: [UUID!] = null @deprecated(reason: "Replaced by the 'org_unit' filter")

  "Registration filter limiting which entries are returned.\n"
  registration: ManagerRegistrationFilter = null

  "Responsibility filter limiting which entries are returned.\n"
  responsibility: ClassFilter = null
}

"""Manager registration filter."""
input ManagerRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type ManagerResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): Manager

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [Manager!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [Manager!]!
}

"""Result page in cursor-based pagination."""
type ManagerResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [ManagerResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input ManagerTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID of the manager we want to terminate."""
  uuid: UUID!
}

input ManagerUpdateInput {
  """UUID of the manager to be updated."""
  uuid: UUID!

  """Validity range for the manager to be updated."""
  validity: RAValidityInput!

  """Extra info or uuid."""
  user_key: String = null

  """UUID of the manager as person to be updated."""
  person: UUID = null

  """UUID of the managers responsibilities to be updated."""
  responsibility: [UUID!] = null

  """UUID of the managers organisation unit to be updated."""
  org_unit: UUID = null

  """UUID of the managers type to be updated."""
  manager_type: UUID = null

  """UUID of the managers level to be updated."""
  manager_level: UUID = null
}

input ModelsUuidsBoundRegistrationFilter {
  actors: [UUID!] = null
  start: DateTime = null
  end: DateTime = null
}

type MultifieldAddress implements ResolvedAddress {
  value: String!
  value2: String!
  name: String!
}

"Entrypoint for all modification-operations.\n\n**Warning**:\nDo **not** use any `*_delete`-mutators without **thoroughly** understanding its implications and the documentation.\n"
type Mutation {
  """Creates an address."""
  address_create(input: AddressCreateInput!): AddressResponse!

  """Creates a list of address."""
  addresses_create(input: [AddressCreateInput!]!): [AddressResponse!]!

  """Updates an address."""
  address_update(input: AddressUpdateInput!): AddressResponse!

  """Terminates an address."""
  address_terminate(input: AddressTerminateInput!): AddressResponse!

  "Deletes an address.\n**Warning**:\nThis mutator does bitemporal deletion, **not** temporal termination.\nDo **not** use this mutator **unless** you **fully understand** its implications.\n\nBitemporal deletion and temporal termination are **very** different operations and should **not** be confused.\nIf you do not know which of the operations you need, you most likely need temporal termination.\n\nBitemporal deletion works on the bitemporal time-axis, and should **only** be used by clients that **fully understand** the underlying bitemporal model, including how a bitemporal delete affects the registration history.\n\nAfter this call the deleted entity will no longer show up in **any** temporal listing.\n\nNote:\nIt is currently the callers responsibility to ensure that references are dealt with before doing bitemporal deletions.\nFailure to do so **will** leave dangling references breaking temporal foreign-keys, and potentially breaking invariants in the data.\n"
  address_delete(uuid: UUID!): AddressResponse!

  """Refresh addresses."""
  address_refresh(
    filter: AddressFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates an association."""
  association_create(input: AssociationCreateInput!): AssociationResponse!

  """Updates an association."""
  association_update(input: AssociationUpdateInput!): AssociationResponse!

  """Terminates an association"""
  association_terminate(input: AssociationTerminateInput!): AssociationResponse!

  """Refresh associations."""
  association_refresh(
    filter: AssociationFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates a class."""
  class_create(input: ClassCreateInput!): ClassResponse!

  """Updates a class."""
  class_update(input: ClassUpdateInput!): ClassResponse!

  """Terminates a class."""
  class_terminate(input: ClassTerminateInput!): ClassResponse!

  "Deletes a class.\n**Warning**:\nThis mutator does bitemporal deletion, **not** temporal termination.\nDo **not** use this mutator **unless** you **fully understand** its implications.\n\nBitemporal deletion and temporal termination are **very** different operations and should **not** be confused.\nIf you do not know which of the operations you need, you most likely need temporal termination.\n\nBitemporal deletion works on the bitemporal time-axis, and should **only** be used by clients that **fully understand** the underlying bitemporal model, including how a bitemporal delete affects the registration history.\n\nAfter this call the deleted entity will no longer show up in **any** temporal listing.\n\nNote:\nIt is currently the callers responsibility to ensure that references are dealt with before doing bitemporal deletions.\nFailure to do so **will** leave dangling references breaking temporal foreign-keys, and potentially breaking invariants in the data.\n"
  class_delete(uuid: UUID!): ClassResponse!

  """Refresh classes."""
  class_refresh(
    filter: ClassFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates an employee."""
  employee_create(input: EmployeeCreateInput!): EmployeeResponse!

  """Updates an employee."""
  employee_update(input: EmployeeUpdateInput!): EmployeeResponse!

  """Terminates an employee."""
  employee_terminate(input: EmployeeTerminateInput!): EmployeeResponse!

  "Deletes an employee.\n**Warning**:\nThis mutator does bitemporal deletion, **not** temporal termination.\nDo **not** use this mutator **unless** you **fully understand** its implications.\n\nBitemporal deletion and temporal termination are **very** different operations and should **not** be confused.\nIf you do not know which of the operations you need, you most likely need temporal termination.\n\nBitemporal deletion works on the bitemporal time-axis, and should **only** be used by clients that **fully understand** the underlying bitemporal model, including how a bitemporal delete affects the registration history.\n\nAfter this call the deleted entity will no longer show up in **any** temporal listing.\n\nNote:\nIt is currently the callers responsibility to ensure that references are dealt with before doing bitemporal deletions.\nFailure to do so **will** leave dangling references breaking temporal foreign-keys, and potentially breaking invariants in the data.\n"
  employee_delete(uuid: UUID!): EmployeeResponse!

  """Refresh employees."""
  employee_refresh(
    filter: EmployeeFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates an engagement."""
  engagement_create(input: EngagementCreateInput!): EngagementResponse!

  """Creates a list of engagements."""
  engagements_create(input: [EngagementCreateInput!]!): [EngagementResponse!]!

  """Updates an engagement."""
  engagement_update(input: EngagementUpdateInput!): EngagementResponse!

  "Updates a list of engagements.\n\nNote: If any of the updates in the transaction is a noop, the whole\ntransaction will fail with the error:\n`(psycopg.errors.InFailedSqlTransaction) current transaction is aborted,\ncommands ignored until end of transaction block`\n\nhttps://redmine.magenta.dk/issues/60573\n"
  engagements_update(input: [EngagementUpdateInput!]!): [EngagementResponse!]!

  """Terminates an engagement."""
  engagement_terminate(input: EngagementTerminateInput!): EngagementResponse!

  "Deletes an engagement.\n**Warning**:\nThis mutator does bitemporal deletion, **not** temporal termination.\nDo **not** use this mutator **unless** you **fully understand** its implications.\n\nBitemporal deletion and temporal termination are **very** different operations and should **not** be confused.\nIf you do not know which of the operations you need, you most likely need temporal termination.\n\nBitemporal deletion works on the bitemporal time-axis, and should **only** be used by clients that **fully understand** the underlying bitemporal model, including how a bitemporal delete affects the registration history.\n\nAfter this call the deleted entity will no longer show up in **any** temporal listing.\n\nNote:\nIt is currently the callers responsibility to ensure that references are dealt with before doing bitemporal deletions.\nFailure to do so **will** leave dangling references breaking temporal foreign-keys, and potentially breaking invariants in the data.\n"
  engagement_delete(uuid: UUID!): EngagementResponse!

  """Refresh engagements."""
  engagement_refresh(
    filter: EngagementFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates a facet."""
  facet_create(input: FacetCreateInput!): FacetResponse!

  """Updates a facet."""
  facet_update(input: FacetUpdateInput!): FacetResponse!

  """Terminates a facet."""
  facet_terminate(input: FacetTerminateInput!): FacetResponse!

  "Deletes a facet.\n**Warning**:\nThis mutator does bitemporal deletion, **not** temporal termination.\nDo **not** use this mutator **unless** you **fully understand** its implications.\n\nBitemporal deletion and temporal termination are **very** different operations and should **not** be confused.\nIf you do not know which of the operations you need, you most likely need temporal termination.\n\nBitemporal deletion works on the bitemporal time-axis, and should **only** be used by clients that **fully understand** the underlying bitemporal model, including how a bitemporal delete affects the registration history.\n\nAfter this call the deleted entity will no longer show up in **any** temporal listing.\n\nNote:\nIt is currently the callers responsibility to ensure that references are dealt with before doing bitemporal deletions.\nFailure to do so **will** leave dangling references breaking temporal foreign-keys, and potentially breaking invariants in the data.\n"
  facet_delete(uuid: UUID!): FacetResponse!

  """Refresh facets."""
  facet_refresh(
    filter: FacetFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates an IT-Association."""
  itassociation_create(input: ITAssociationCreateInput!): AssociationResponse!

  """Updates an IT-Association."""
  itassociation_update(input: ITAssociationUpdateInput!): AssociationResponse!

  """Terminates an ITAssociation."""
  itassociation_terminate(input: ITAssociationTerminateInput!): AssociationResponse!

  """Creates an ITSystem."""
  itsystem_create(input: ITSystemCreateInput!): ITSystemResponse!

  """Updates an ITSystem."""
  itsystem_update(input: ITSystemUpdateInput!): ITSystemResponse!

  """Terminates an IT-System."""
  itsystem_terminate(input: ITSystemTerminateInput!): ITSystemResponse!

  "Deletes an ITSystem.\n**Warning**:\nThis mutator does bitemporal deletion, **not** temporal termination.\nDo **not** use this mutator **unless** you **fully understand** its implications.\n\nBitemporal deletion and temporal termination are **very** different operations and should **not** be confused.\nIf you do not know which of the operations you need, you most likely need temporal termination.\n\nBitemporal deletion works on the bitemporal time-axis, and should **only** be used by clients that **fully understand** the underlying bitemporal model, including how a bitemporal delete affects the registration history.\n\nAfter this call the deleted entity will no longer show up in **any** temporal listing.\n\nNote:\nIt is currently the callers responsibility to ensure that references are dealt with before doing bitemporal deletions.\nFailure to do so **will** leave dangling references breaking temporal foreign-keys, and potentially breaking invariants in the data.\n"
  itsystem_delete(uuid: UUID!): ITSystemResponse!

  """Refresh ITSystems."""
  itsystem_refresh(
    filter: ITSystemFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates an IT-User."""
  ituser_create(input: ITUserCreateInput!): ITUserResponse!

  """Creates a list of itusers."""
  itusers_create(input: [ITUserCreateInput!]!): [ITUserResponse!]!

  """Updates an IT-User."""
  ituser_update(input: ITUserUpdateInput!): ITUserResponse!

  """Terminates IT-User."""
  ituser_terminate(input: ITUserTerminateInput!): ITUserResponse!

  "Deletes an IT-User.\n**Warning**:\nThis mutator does bitemporal deletion, **not** temporal termination.\nDo **not** use this mutator **unless** you **fully understand** its implications.\n\nBitemporal deletion and temporal termination are **very** different operations and should **not** be confused.\nIf you do not know which of the operations you need, you most likely need temporal termination.\n\nBitemporal deletion works on the bitemporal time-axis, and should **only** be used by clients that **fully understand** the underlying bitemporal model, including how a bitemporal delete affects the registration history.\n\nAfter this call the deleted entity will no longer show up in **any** temporal listing.\n\nNote:\nIt is currently the callers responsibility to ensure that references are dealt with before doing bitemporal deletions.\nFailure to do so **will** leave dangling references breaking temporal foreign-keys, and potentially breaking invariants in the data.\n"
  ituser_delete(uuid: UUID!): ITUserResponse!

  """Refresh IT-Users."""
  ituser_refresh(
    filter: ITUserFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates a KLE annotation."""
  kle_create(input: KLECreateInput!): KLEResponse!

  """Updates a KLE annotation."""
  kle_update(input: KLEUpdateInput!): KLEResponse!

  """Terminates a KLE annotation."""
  kle_terminate(input: KLETerminateInput!): KLEResponse!

  """Refresh KLEs."""
  kle_refresh(
    filter: KLEFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates a leave."""
  leave_create(input: LeaveCreateInput!): LeaveResponse!

  """Updates a leave."""
  leave_update(input: LeaveUpdateInput!): LeaveResponse!

  """Terminates a leave."""
  leave_terminate(input: LeaveTerminateInput!): LeaveResponse!

  """Refresh leaves."""
  leave_refresh(
    filter: LeaveFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates a manager relation."""
  manager_create(input: ManagerCreateInput!): ManagerResponse!

  """Creates a list of managers."""
  managers_create(input: [ManagerCreateInput!]!): [ManagerResponse!]!

  """Updates a manager relation."""
  manager_update(input: ManagerUpdateInput!): ManagerResponse!

  """Terminates a manager relation."""
  manager_terminate(input: ManagerTerminateInput!): ManagerResponse!

  """Refresh managers."""
  manager_refresh(
    filter: ManagerFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates the root-organisation."""
  org_create(input: OrganisationCreate!): Organisation! @deprecated(reason: "The root organisation concept will be removed in a future version of OS2mo.")

  """Creates an organisation unit."""
  org_unit_create(input: OrganisationUnitCreateInput!): OrganisationUnitResponse!

  """Updates an organisation unit."""
  org_unit_update(input: OrganisationUnitUpdateInput!): OrganisationUnitResponse!

  """Terminates an organization unit."""
  org_unit_terminate(input: OrganisationUnitTerminateInput!): OrganisationUnitResponse!

  """Refresh organization units."""
  org_unit_refresh(
    filter: OrganisationUnitFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Creates an owner."""
  owner_create(input: OwnerCreateInput!): OwnerResponse!

  """Updates an owner."""
  owner_update(input: OwnerUpdateInput!): OwnerResponse!

  """Terminates an owner."""
  owner_terminate(input: OwnerTerminateInput!): OwnerResponse!

  """Refresh owners."""
  owner_refresh(
    filter: OwnerFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Updates relations for an org_unit."""
  related_units_update(input: RelatedUnitsUpdateInput!): RelatedUnitResponse!

  """Refresh a related unit."""
  related_unit_refresh(
    filter: RelatedUnitFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  """Create a rolebinding."""
  rolebinding_create(input: RoleBindingCreateInput!): RoleBindingResponse!

  """Creates a list of rolebindings."""
  rolebindings_create(input: [RoleBindingCreateInput!]!): [RoleBindingResponse!]!

  """Update a rolebinding."""
  rolebinding_update(input: RoleBindingUpdateInput!): RoleBindingResponse!

  """Terminate a rolebinding."""
  rolebinding_terminate(input: RoleBindingTerminateInput!): RoleBindingResponse!

  """Refresh rolebindings."""
  rolebinding_refresh(
    filter: RoleBindingFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
    queue: String = null @deprecated(reason: "Never worked properly. Use `exchange` to target a specific integration instead.")
    exchange: String = null
  ): UUIDPaged!

  "Upload a file.\n\nFile upload must be done via multipart form-data.\n\nHow to do this is client-specific, but below is an example using [curl](https://curl.se/):\n```console\ncurl https://{{MO_URL}}/graphql/v7 \\\n  -H \"Authorization: Bearer {{TOKEN}}\" \\\n  -F operations=\"{\\\"query\\\": \\\"{{QUERY}}\\\", \\\n      \\\"variables\\\": {\\\"file\\\": null}}\" \\\n  -F map='{\"file\": [\"variables.file\"]}' \\\n  -F file=@myfile.txt\n```\nWhere:\n* `myfile.txt` is the file to upload.\n* `{{MO_URL}}` is the base-url for the OS2mo instance to upload the file to.\n* `{{TOKEN}}` is a valid JWT-token acquired from Keycloak.\n* `{{QUERY}}` is the upload query:\n```gql\nmutation($file: Upload!) {\n  upload_file(\n    file_store: EXPORTS,\n    file: $file\n  )\n}\n```\n\nNote:\nAs GraphiQL does not support sending multipart form-data payloads, it is unfortunately not possible to upload files from GraphiQL.\n"
  upload_file(
    """The filestore to upload the file into"""
    file_store: FileStore!

    "Multipart form-data file payload.\n\nContains both the data and the filename to be uploaded.\n\nSee the `upload_file`-mutator description for how to send this.\n"
    file: Upload!

    """Whether to override pre-existing files."""
    force: Boolean! = false
  ): String!
}

"""Validity of objects with optional from date"""
type OpenValidity {
  """Start date of the validity."""
  from: DateTime

  """End date of the validity, if applicable."""
  to: DateTime
}

input OrgUnitsboundaddressfilter {
  org_unit: OrganisationUnitFilter = null
  employee: EmployeeFilter = null
  employees: [UUID!] = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: AddressRegistrationFilter = null
  address_type: ClassFilter = null
  address_types: [UUID!] = null
  address_type_user_keys: [String!] = null
  engagement: EngagementFilter = null
  engagements: [UUID!] = null
  ituser: ITUserFilter = null
  visibility: ClassFilter = null
}

input OrgUnitsboundassociationfilter {
  org_unit: OrganisationUnitFilter = null
  employee: EmployeeFilter = null
  employees: [UUID!] = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: AssociationRegistrationFilter = null
  association_type: ClassFilter = null
  association_types: [UUID!] = null
  association_type_user_keys: [String!] = null
  it_association: Boolean = null
}

input OrgUnitsboundengagementfilter {
  org_unit: OrganisationUnitFilter = null
  employee: EmployeeFilter = null
  employees: [UUID!] = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: EngagementRegistrationFilter = null
  job_function: ClassFilter = null
  engagement_type: ClassFilter = null
}

input OrgUnitsboundituserfilter {
  org_unit: OrganisationUnitFilter = null
  employee: EmployeeFilter = null
  employees: [UUID!] = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: ITUserRegistrationFilter = null
  itsystem: ITSystemFilter = null
  itsystem_uuids: [UUID!] = null
  engagement: EngagementFilter = null
  external_ids: [String!] = null
}

input OrgUnitsboundklefilter {
  org_unit: OrganisationUnitFilter = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: KLERegistrationFilter = null
}

input OrgUnitsboundleavefilter {
  org_unit: OrganisationUnitFilter = null
  employee: EmployeeFilter = null
  employees: [UUID!] = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: LeaveRegistrationFilter = null
}

input OrgUnitsboundmanagerfilter {
  org_unit: OrganisationUnitFilter = null
  employee: EmployeeFilter = null
  employees: [UUID!] = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: ManagerRegistrationFilter = null
  responsibility: ClassFilter = null
}

input OrgUnitsboundrelatedunitfilter {
  org_unit: OrganisationUnitFilter = null
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
}

"""Root organisation - one and only one of these can exist"""
type Organisation {
  """UUID of the entity"""
  uuid: UUID!

  "Short unique key.\n\nExamples:\n* `root`\n* `0751` (municipality code)\n* `3b866d97-0b1f-48e0-8078-686d96f430b3` (copied entity UUID)\n* `Kolding Kommune` (municipality name)\n* `Magenta ApS` (company name)\n"
  user_key: String!

  "Name of the organisation.\n\nExamples:\n* `root`\n* `Kolding Kommune` (or similar municipality name)\n* `Magenta ApS` (or similar company name)\n"
  name: String!

  "The object type.\n\nAlways contains the string `organisation`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  "The municipality code.\n\nIn Denmark; a 3 digit number uniquely identifying a municipality.\nGenerally used to map the Local administrative units (LAU) of the\nNomenclature of Territorial Units for Statistics (NUTS) standard.\n\nA list of all danish municipality codes can be found here:\n* https://danmarksadresser.dk/adressedata/kodelister/kommunekodeliste\n\nExamples:\n* `null` (unset)\n* `101` (Copenhagen)\n* `461` (Odense)\n* `751` (Aarhus)\n"
  municipality_code: Int
}

input OrganisationCreate {
  "The municipality code.\n\nIn Denmark; a 3 digit number uniquely identifying a municipality.\nGenerally used to map the Local administrative units (LAU) of the\nNomenclature of Territorial Units for Statistics (NUTS) standard.\n\nA list of all danish municipality codes can be found here:\n* https://danmarksadresser.dk/adressedata/kodelister/kommunekodeliste\n\nExamples:\n* `null` (unset)\n* `101` (Copenhagen)\n* `461` (Odense)\n* `751` (Aarhus)\n"
  municipality_code: Int
}

"""Organisation unit within the organisation tree"""
type OrganisationUnit {
  "The parent organisation unit in the organisation tree.\n"
  parent(
    filter: UuidsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): OrganisationUnit

  "The immediate descendants in the organisation tree\n"
  children(
    filter: ParentsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [OrganisationUnit!]!

  """
  Children count of the organisation unit. For performance, consider if `has_children` can answer your query instead.
  """
  child_count(filter: ParentsBoundOrganisationUnitFilter): Int!

  """Returns whether the organisation unit has children."""
  has_children(filter: ParentsBoundOrganisationUnitFilter): Boolean!

  "Organisation unit hierarchy.\n\nCan be used to label an organisational structure to belong to a certain subset of the organisation tree.\n\nExamples of user-keys:\n* `\"Line-management\"`\n* `\"Self-owned institution\"`\n* `\"Outside organisation\"`\n* `\"Hidden\"`\n\nNote:\nThe organisation-gatekeeper integration is one option to keep hierarchy labels up-to-date.\n"
  org_unit_hierarchy_model(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  "Organisation unit type.\n\nOrganisation units can represent a lot of different classes of hierarchical structures.\nSometimes they represent cooperations, governments, NGOs or other true organisation types.\nOftentimes they represent the inner structure of these organisations.\nOthertimes they represent project management structures such as project or teams.\n\nThis field is used to distriguish all these different types of organisations.\n\nExamples of user-keys:\n* `\"Private Company\"`\n* `\"Educational Institution\"`\n* `\"Activity Center\"`\n* `\"Daycare\"`\n* `\"Team\"`\n* `\"Project\"`\n"
  unit_type(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  "Organisation unit level.\n\nExamples of user-keys:\n* `\"N1\"`\n* `\"N5\"`\n* `\"N7\"`\n"
  org_unit_level(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  "Time planning strategy.\n"
  time_planning(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): Class

  "Engagements for the organistion unit.\n\nMay be an empty list if the organistion unit does not have any people employeed.\nThis situation may occur especially in the middle or the organisation tree.\n"
  engagements(
    filter: OrgUnitsboundengagementfilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Engagement!]!

  "Managerial roles for the organisation unit.\n\nMay be empty in which case managers are usually inherited from parents.\nSee the `inherit`-flag for details.\n"
  managers(
    filter: OrgUnitsboundmanagerfilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null

    "Whether to inherit managerial roles or not.\n\nIf managerial roles exist directly on this organisation unit, the flag does nothing and these managerial roles are returned.\nHowever if no managerial roles exist directly, and this flag is:\n* False: An empty list is returned.\n* True: The result from calling `managers` with `inherit=True` on the parent of this organistion unit is returned.\n\nCalling with `inherit=True` can help ensure that a manager is always found.\n"
    inherit: Boolean! = false
  ): [Manager!]!

  "Addresses for the organisation unit.\n\nCommonly contain addresses such as, their:\n* Location\n* Contact phone number\n* Contact email\n"
  addresses(
    filter: OrgUnitsboundaddressfilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Address!]!

  "Connection to employees leaves of absence relevant for the organisation unit.\n"
  leaves(
    filter: OrgUnitsboundleavefilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Leave!]!

  "Associations for the organistion unit.\n\nMay be an empty list if the organistion unit is purely hierarchical.\nThis situation may occur especially in the middle or the organisation tree.\n"
  associations(
    filter: OrgUnitsboundassociationfilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Association!]!

  "IT (service) accounts.\n\nMay be an empty list if the organistion unit does not have any IT (service) accounts whatsoever.\nThis situation may occur especially in the middle or the organisation tree.\n"
  itusers(
    filter: OrgUnitsboundituserfilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [ITUser!]!

  "KLE responsibilities for the organisation unit.\n\nCan help out with regards to GDPR by identifying which organisational units operate with sensitive tasks.\n"
  kles(
    filter: OrgUnitsboundklefilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [KLE!]!

  "Related units for the organisational unit.\n"
  related_units(
    filter: OrgUnitsboundrelatedunitfilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [RelatedUnit!]!

  "All ancestor organisational units in the organisation tree.\n\nThe result of collecting organisational units by following `parent` until `parent` becomes `null`.\nI.e. the list of all ancestors on the way to the organisation tree root.\n"
  ancestors: [OrganisationUnit!]!

  "The object type.\n\nAlways contains the string `org_unit`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the entity"""
  uuid: UUID!

  "Short unique key.\n\nUsually set to be set to the key used in external systems.\n\nExamples:\n* `\"CBCM\"`\n* `\"SPHA\"`\n* `\"1414\"`\n"
  user_key: String!

  "Human readable name of the organisation unit.\n\nThis is the value that should be shown to users in UIs.\n\nExamples:\n* `\"Lunderskov skole\"`\n* `\"IT-Support\"`\n* `\"Teknik og Milj\"`\n"
  name: String!

  "Owner roles for the organisation unit.\n\nMay be empty in which case owners are usually inherited from parents.\nSee the `inherit`-flag for details.\n"
  owners(
    filter: OwnerFilter = null

    "Whether to inherit owner roles or not.\n\nIf owner roles exist directly on this organisaion unit, the flag does nothing and these owner roles are returned.\nHowever if no owner roles exist directly, and this flag is:\n* Not set: An empty list is returned.\n* Is set: The result from calling `owners` with `inherit=True` on the parent of this organistion unit is returned.\n\nCalling with `inherit=True` can help ensure that an owner is always found.\n"
    inherit: Boolean! = false
  ): [Owner!]!

  """UUID of the parent organisation unit."""
  org_unit_hierarchy: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `org_unit_hierarchy_model {uuid}` instead.\n")

  """UUID of the parent organisation unit."""
  parent_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `parent {uuid}` instead.\n")

  """UUID of the organisation unit type."""
  unit_type_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `unit_type {uuid}` instead.\n")

  """UUID of the organisation unit level."""
  org_unit_level_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `org_unit_level {uuid}` instead.\n")

  """UUID of the time planning object."""
  time_planning_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `time_planning {uuid}` instead.\n")

  "Same as ancestors(), but with HACKs to enable validities.\n"
  ancestors_validity: [OrganisationUnit!]! @deprecated(reason: "Should only be used to query ancestors when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  "Same as associations(), but with HACKs to enable validities.\n"
  associations_validity: [Association!]! @deprecated(reason: "Should only be used to query associations when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  "Same as addresses(), but with HACKs to enable validities.\n"
  addresses_validity: [Address!]! @deprecated(reason: "Should only be used to query addresses when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  "Same as itusers(), but with HACKs to enable validities.\n"
  itusers_validity: [ITUser!]! @deprecated(reason: "Should only be used to query itusers when validity dates have been specified, \"\n\"ex from_date & to_date.\"\n\"Will be removed when sub-query date handling is implemented.\n")

  """Validity of the created organisation unit."""
  validity: Validity!
}

input OrganisationUnitCreateInput {
  uuid: UUID
  validity: RAValidityInput!
  name: String!
  user_key: String
  parent: UUID
  org_unit_type: UUID!
  time_planning: UUID
  org_unit_level: UUID
  org_unit_hierarchy: UUID
}

"Organisation unit filter.\n\nConsider the tree:\n```\n    root\n    / \\\n   l   r\n  /   / \\\nll   rl  rr\n```\nSetting a filter to `filter=value`, yields:\n\nfilter     | value  | result                | note           |\n-----------|--------|-----------------------|----------------|\nuser_keys  | `root` | `[root]`              |                |\nuser_keys  | `r`    | `[r]`                 |                |\nuser_keys  | `rl`   | `[rl]`                |                |\nchild      | `null` | `[ll, rl, rr]`        | Leaf nodes     |\nchild      | `{}`   | `[root, l, r]`        | Inner nodes    |\nchild      | `r`    | `[root]`              | Parent node    |\nchild      | `rl`   | `[r]`                 | Parent node    |\ndescendant | `null` | `[root,l,r,ll,rl,rr]` | All nodes      |\ndescendant | `{}`   | `[root,l,r,ll,rl,rr]` | All nodes      |\ndescendant | `r`    | `[root, r]`           |                |\ndescendant | `rl`   | `[root, r, rl]`       |                |\nparent     | `null` | `[root]`              | Root node      |\nparent     | `{}`   | `[l,r,ll,rl,rr]`      | Non-root nodes |\nparent     | `r`    | `[rl,rr]`             | Child nodes    |\nparent     | `rl`   | `[]`                  | No children    |\nancestor   | `null` | `[root,l,r,ll,rl,rr]` | All nodes      |\nancestor   | `{}`   | `[root,l,r,ll,rl,rr]` | All nodes      |\nancestor   | `r`    | `[r, rl, rr]`         |                |\nancestor   | `rl`   | `[rl]`                |                |\n\nThese can ofcourse be combined too, such that:\n* `{child: {}, parent: {}}` returns all non-root inner nodes.\n* `{child: null, parent: null}` returns all childless roots.\n* `{child: {}, parent: null}` returns all roots with children.\n* ...\n"
input OrganisationUnitFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Registration filter limiting which entries are returned.\n"
  registration: OrganisationUnitRegistrationFilter = null

  "Free text search.\n\nDoes best effort lookup to find entities matching the query string.\nNo quarantees are given w.r.t. the entries returned.\n"
  query: String

  "Name filter finding exact matches by name.\n\n| `names`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  names: [String!]

  "Select organisation units whose parent matches the given filter.\n\nSet to `None` to find root units.\nSet to `{}` to find non-root units.\n\nThis endpoint behaves to ancestor as child does to descendant.\n"
  parent: OrganisationUnitFilter

  "Parent UUID filter limiting which entries are returned.\n\n| `parents`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  parents: [UUID!] @deprecated(reason: "Replaced by the 'parent' filter")

  "Select organisation units whose children matches the given filter.\n\nSet to `None` to find leaf node units.\nSet to `{}` to find inner node units.\n\nThis endpoint behaves to descendant as parent does to ancestor.\n"
  child: OrganisationUnitFilter

  "Hierarchy filter limiting which entries are returned.\n\nFilter organisation units by their organisational hierarchy labels.\n\nCan be used to extract a subset of the organisational structure.\n\nExamples of user-keys:\n* `\"Line-management\"`\n* `\"Self-owned institution\"`\n* `\"Outside organisation\"`\n* `\"Hidden\"`\n\nNote:\nThe organisation-gatekeeper integration is one option to keep hierarchy labels up-to-date.\n"
  hierarchy: ClassFilter = null

  "Filter organisation units by their organisational hierarchy labels.\n\nCan be used to extract a subset of the organisational structure.\n\nExamples of user-keys:\n* `\"Line-management\"`\n* `\"Self-owned institution\"`\n* `\"Outside organisation\"`\n* `\"Hidden\"`\n\nNote:\nThe organisation-gatekeeper integration is one option to keep hierarchy labels up-to-date.\n\n| `hierarchies`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  hierarchies: [UUID!] = null @deprecated(reason: "Replaced by the 'hierarchy' filter")
  subtree: OrganisationUnitFilter @deprecated(reason: "Renamed to 'descendant'")

  "Select organisation units which have a descendant matching the given filter.\n\nNote that every node is its own descendant as per [CLRS] 12.2-6.\n\nGiven the following tree:\n```\nA\n B\n    C\n       D\n    E\n F\n```\nthe `descendant` filter behaves according to the following table:\n\n| Filter | Returned    |\n|--------|-------------|\n|      A | A           |\n|      B | A B         |\n|      C | A B C       |\n|      D | A B C D     |\n|      E | A B E       |\n|      F | A F         |\n"
  descendant: OrganisationUnitFilter

  "Select organisation units which have an ancestor matching the given filter.\n\nNote that every node is its own ancestor as per [CLRS] 12.2-6.\n\nGiven the following tree:\n```\nA\n B\n    C\n       D\n    E\n F\n```\nthe `ancestor` filter behaves according to the following table:\n\n| Filter | Returned    |\n|--------|-------------|\n|      A | A B C D E F |\n|      B | B C D E     |\n|      C | C D         |\n|      D | D           |\n|      E | E           |\n|      F | F           |\n"
  ancestor: OrganisationUnitFilter

  "Filter organisation units to only include matches pointed to by engagements.\n\nCan be used to find organisation units for certain engagements.\n"
  engagement: EngagementFilter = null
}

"""OrganisationUnit registration filter."""
input OrganisationUnitRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type OrganisationUnitResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): OrganisationUnit

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [OrganisationUnit!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [OrganisationUnit!]!
}

"""Result page in cursor-based pagination."""
type OrganisationUnitResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [OrganisationUnitResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input OrganisationUnitTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID for the org-unit we want to terminate."""
  uuid: UUID!
}

input OrganisationUnitUpdateInput {
  uuid: UUID!
  validity: RAValidityInput!
  name: String
  user_key: String
  parent: UUID
  org_unit_type: UUID
  org_unit_level: UUID
  org_unit_hierarchy: UUID
  time_planning: UUID
}

"\nOwner of organisation units/employees and their connected identities.\n"
type Owner {
  "The owned organisation unit.\n\nNote:\nThis field is mutually exclusive with the `employee` field.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  org_unit(
    filter: UuidsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [OrganisationUnit!]

  "The owned person.\n\nNote:\nThis field is mutually exclusive with the `org_unit` field.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  person(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]

  "Owner of the connected person or organisation unit.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  owner(
    filter: UuidsBoundEmployeeFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Employee!]

  "\nThe object type.\n\nAlways contains the string `owner`.\n"
  type: String! @deprecated(reason: "\nUnintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUID of the entity"""
  uuid: UUID!

  """UUID of the organisation unit related to the owner."""
  org_unit_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `org_unit {uuid}` instead.\n")

  """UUID of the employee related to the owner."""
  employee_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `employee {uuid}` instead.\n")

  """UUID of the owner."""
  owner_uuid: UUID @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `owner {uuid}` instead.\n")

  """Short, unique key. Defaults to object UUID."""
  user_key: String!

  """Validity of the owner object."""
  validity: Validity!

  """
  Inference priority, if set: `engagement_priority` or `association_priority`
  """
  owner_inference_priority: OwnerInferencePriority
}

input OwnerCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """Extra info or uuid."""
  user_key: String = null

  """UUID of the org unit"""
  org_unit: UUID = null

  """UUID of the person"""
  person: UUID = null

  """UUID of the owner"""
  owner: UUID = null

  """
  Inference priority, if set: `engagement_priority` or `association_priority`
  """
  inference_priority: OwnerInferencePriority = null

  """Validity range for the owner."""
  validity: RAValidityInput!
}

"""Owner filter."""
input OwnerFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Employee filter limiting which entries are returned.\n"
  employee: EmployeeFilter = null

  "Employee UUID filter limiting which entries are returned.\n\n| `employees`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  employees: [UUID!] = null @deprecated(reason: "Replaced by the 'employee' filter")

  "Organisation Unit filter limiting which entries are returned.\n"
  org_unit: OrganisationUnitFilter = null

  "Organisational Unit UUID filter limiting which entries are returned.\n\n| `org_units`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  org_units: [UUID!] = null @deprecated(reason: "Replaced by the 'org_unit' filter")

  "Owner filter limiting which entries are returned.\n"
  owner: EmployeeFilter = null
}

"Enum for the supported inference priorities.\n"
enum OwnerInferencePriority {
  "The engagement priority.\n"
  ENGAGEMENT

  "The association priority.\n"
  ASSOCIATION
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type OwnerResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): Owner

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [Owner!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [Owner!]!
}

"""Result page in cursor-based pagination."""
type OwnerResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [OwnerResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input OwnerTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID of the owner we want to terminate."""
  uuid: UUID!
}

input OwnerUpdateInput {
  """UUID of the owner to be updated."""
  uuid: UUID!

  """Extra info or uuid."""
  user_key: String = null

  """UUID of the org unit"""
  org_unit: UUID = null

  """UUID of the person"""
  person: UUID = null

  """UUID of the owner"""
  owner: UUID = null

  """
  Inference priority, if set: `engagement_priority` or `association_priority`
  """
  inference_priority: OwnerInferencePriority = null

  """Validity range for the owner."""
  validity: RAValidityInput!
}

"Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
type PageInfo {
  "Cursor for the next page of results.\n\nShould be provided to the `cursor` argument to iterate forwards.\n"
  next_cursor: Cursor
}

input ParentsBoundClassFilter {
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: ClassRegistrationFilter = null
  facet: FacetFilter = null
  facets: [UUID!] = null
  facet_user_keys: [String!] = null
  parent: ClassFilter = null
  parent_user_keys: [String!] = null
  it_system: ITSystemFilter = null
  owner: ClassOwnerFilter = null
  scope: [String!] = null
}

input ParentsBoundFacetFilter {
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: FacetRegistrationFilter = null
  parent: FacetFilter = null
  parent_user_keys: [String!] = null
}

input ParentsBoundOrganisationUnitFilter {
  uuids: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: OrganisationUnitRegistrationFilter = null
  query: String
  names: [String!]
  parent: OrganisationUnitFilter
  child: OrganisationUnitFilter
  hierarchy: ClassFilter = null
  hierarchies: [UUID!] = null
  subtree: OrganisationUnitFilter
  descendant: OrganisationUnitFilter
  ancestor: OrganisationUnitFilter
  engagement: EngagementFilter = null
}

"""Entrypoint for all read-operations"""
type Query {
  """Get addresses."""
  addresses(
    filter: AddressFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): AddressResponsePaged!

  """Get associations."""
  associations(
    filter: AssociationFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): AssociationResponsePaged!

  """Get classes."""
  classes(
    filter: ClassFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): ClassResponsePaged!

  """Get employees."""
  employees(
    filter: EmployeeFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): EmployeeResponsePaged!

  """Get engagements."""
  engagements(
    filter: EngagementFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): EngagementResponsePaged!

  """Get facets."""
  facets(
    filter: FacetFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): FacetResponsePaged!

  """Get it-systems."""
  itsystems(
    filter: ITSystemFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): ITSystemResponsePaged!

  """Get it-users."""
  itusers(
    filter: ITUserFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): ITUserResponsePaged!

  """Get kles."""
  kles(
    filter: KLEFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): KLEResponsePaged!

  """Get leaves."""
  leaves(
    filter: LeaveFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): LeaveResponsePaged!

  """Get manager roles."""
  managers(
    filter: ManagerFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null

    "Whether to inherit managerial roles or not.\n\nIf managerial roles exist directly on this organisation unit, the flag does nothing and these managerial roles are returned.\nHowever if no managerial roles exist directly, and this flag is:\n* False: An empty list is returned.\n* True: The result from calling `managers` with `inherit=True` on the parent of this organistion unit is returned.\n\nCalling with `inherit=True` can help ensure that a manager is always found.\n"
    inherit: Boolean! = false
  ): ManagerResponsePaged!

  """Get owners."""
  owners(
    filter: OwnerFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): OwnerResponsePaged!

  """Get organisation units."""
  org_units(
    filter: OrganisationUnitFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): OrganisationUnitResponsePaged!

  """Get related organisation units."""
  related_units(
    filter: RelatedUnitFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): RelatedUnitResponsePaged!

  """Get role-mappings."""
  rolebindings(
    filter: RoleBindingFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): RoleBindingResponsePaged!

  """Query healthcheck status."""
  healths(
    filter: HealthFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): HealthPaged!

  """Fetch files from the configured file backend (if any)."""
  files(
    filter: FileFilter!

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): FilePaged! @deprecated(reason: "The file-store functionality will be removed in a future version of OS2mo.")

  """Get configuration variables."""
  configuration(
    filter: ConfigurationFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): ConfigurationPaged!

  "Get a list of registrations.\n\nMostly useful for auditing purposes seeing when data-changes were made and by whom.\n\n**Warning**:\nThis entry should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: RegistrationFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): RegistrationPaged!

  "Get a list of audit events.\n\nMostly useful for auditing purposes seeing when data was read and by whom.\n"
  auditlog(
    filter: AuditLogFilter = null

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): AuditLogPaged!

  "Get the root organisation.\n\nThis endpoint fails if not exactly one exists in LoRa.\n"
  org: Organisation! @deprecated(reason: "The root organisation concept will be removed in a future version of OS2mo.")

  """Get component versions of OS2mo."""
  version: Version!
}

input RAOpenValidityInput {
  """Start date of the validity."""
  from: DateTime = null

  """End date of the validity, if applicable."""
  to: DateTime = null
}

input RAValidityInput {
  """Start date of the validity."""
  from: DateTime!

  """End date of the validity, if applicable."""
  to: DateTime = null
}

"Bitemporal container.\n\nMostly useful for auditing purposes seeing when data-changes were made and by whom.\n\nNote:\nWill eventually contain a full temporal axis per bitemporal container.\n\n**Warning**:\nThis entry should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
type Registration {
  "Internal registration ID for the registration.\n"
  registration_id: Int! @deprecated(reason: "May be removed in the future once the bitemporal scheme is finished.\n")

  "Start of the bitemporal interval.\n\nExamples:\n* `\"1970-01-01T00:00:00.000000+00:00\"`\n* `\"2019-12-18T12:55:15.348614+00:00\"`\n"
  start: DateTime!

  "End of the bitemporal interval.\n\n`null` indicates the open interval, aka. infinity.\n\nExamples:\n* `\"1970-01-01T00:00:00.000000+00:00\"`\n* `\"2019-12-18T12:55:15.348614+00:00\"`\n* `null`\n"
  end: DateTime

  "UUID of the actor (integration or user) who changed the data.\n\nNote:\nCurrently mostly returns `\"42c432e8-9c4a-11e6-9f62-873cf34a735f\"`.\nWill eventually contain for the UUID of the integration or user who mutated data, based on the JWT token.\n"
  actor: UUID!

  "Model of the modified entity.\n\nExamples:\n* `\"class\"`\n* `\"employee\"`\n* `\"org_unit\"`\n"
  model: String!

  "UUID of the modified entity.\n"
  uuid: UUID!

  """Note associated with the registration."""
  note: String
}

"""Registration filter."""
input RegistrationFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  "Filter registrations by their model type.\n\nCan be used to select all changes of a type.\n\n| `models`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  models: [String!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

"""Result page in cursor-based pagination."""
type RegistrationPaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [Registration!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

"""An organisation unit relation mapping"""
type RelatedUnit {
  "Related organisation units.\n\nExamples of user-keys:\n* `[\"Administrative\", \"Payroll\"]`\n* `[\"IT-Support\", \"IT-Support]`\n* `[\"Majora School\", \"Alias School\"]`\n\nNote:\nThe result list should always be of length 2, corresponding to the elements of the bijection.\n"
  org_units(
    filter: UuidsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [OrganisationUnit!]!

  """UUID of the entity"""
  uuid: UUID!

  "User-key of the entity.\n\nUsually constructed from the user-keys of our organisation units at creation time.\n\nExamples:\n* `\"Administrative <-> Payroll\"`\n* `\"IT-Support <-> IT-Support`\n* `\"Majora School <-> Alias School\"`\n"
  user_key: String!

  "The object type.\n\nAlways contains the string `related_units`.\n"
  type: String! @deprecated(reason: "Unintentionally exposed implementation detail.\nProvides no value whatsoever.\n")

  """UUIDs of the related organisation units."""
  org_unit_uuids: [UUID!]! @deprecated(reason: "Will be removed in a future version of GraphQL.\nUse `org_units {uuid}` instead.\n")

  """Validity of the relatedUnit object."""
  validity: Validity!
}

"""Related unit filter."""
input RelatedUnitFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Organisation Unit filter limiting which entries are returned.\n"
  org_unit: OrganisationUnitFilter = null

  "Organisational Unit UUID filter limiting which entries are returned.\n\n| `org_units`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  org_units: [UUID!] = null @deprecated(reason: "Replaced by the 'org_unit' filter")
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type RelatedUnitResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): RelatedUnit

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [RelatedUnit!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [RelatedUnit!]!
}

"""Result page in cursor-based pagination."""
type RelatedUnitResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [RelatedUnitResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input RelatedUnitsUpdateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """UUID of the unit to create relations under."""
  origin: UUID!

  """UUID of the units to create relations to."""
  destination: [UUID!] = null

  """From date."""
  validity: RAValidityInput!
}

interface ResolvedAddress {
  value: String!
}

"""The role a person has within an organisation unit"""
type RoleBinding {
  "The IT-user that should be granted this role\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  ituser(
    filter: UuidsBoundITUserFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [ITUser!]!

  "The organisational unit in which the role is being fulfilled.\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  org_unit(
    filter: UuidsBoundOrganisationUnitFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [OrganisationUnit!]!

  """UUID of the entity"""
  uuid: UUID!

  """Short, unique key. Defaults to object UUID."""
  user_key: String!

  """Validity of the role object."""
  validity: Validity!

  "The role that is being fulfilled.\n\nExamples of user-keys:\n* `\"AD Read\"`\n* `\"AD Write\"`\n* `\"SAP Admin\"`\n\n**Warning**:\nThis field will probably become an optional entity instead of a list in the future.\n"
  role(
    filter: UuidsBoundClassFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Class!]!
}

input RoleBindingCreateInput {
  """UUID to be created. Will be autogenerated if not specified."""
  uuid: UUID = null

  """Extra info or uuid."""
  user_key: String = null

  """UUID of the org_unit"""
  org_unit: UUID = null

  """UUID of the ituser"""
  ituser: UUID!

  """UUID of the role type"""
  role: UUID!

  """Validity range for the role."""
  validity: RAValidityInput!
}

"""Rolebinding filter."""
input RoleBindingFilter {
  "UUID filter limiting which entries are returned.\n\n| `uuids`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  uuids: [UUID!] = null

  "User-key filter limiting which entries are returned.\n\n| `user_keys`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  user_keys: [String!] = null

  """Limit the elements returned by their starting validity."""
  from_date: DateTime

  """Limit the elements returned by their ending validity."""
  to_date: DateTime

  "Organisation Unit filter limiting which entries are returned.\n"
  org_unit: OrganisationUnitFilter = null

  "Organisational Unit UUID filter limiting which entries are returned.\n\n| `org_units`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  org_units: [UUID!] = null @deprecated(reason: "Replaced by the 'org_unit' filter")

  "Registration filter limiting which entries are returned.\n"
  registration: RoleRegistrationFilter = null

  "ITUser filter limiting which entries are returned.\n"
  ituser: ITUserFilter = null
}

"Top-level container for (bi)-temporal and actual state data access.\n\nContains a UUID uniquely denoting the bitemporal object.\n\nContains three different object temporality axis:\n\n| entrypoint      | temporal axis | validity time | assertion time |\n|-----------------|---------------|---------------|----------------|\n| `current`       | actual state  | current       | current        |\n| `objects`       | temporal      | varying       | current        |\n| `registrations` | bitemporal    | varying       | varying        |\n\nThe argument for having three different entrypoints into the data is limiting complexity according to use-case.\n\nThat is, if a certain integration or UI only needs, say, actual state data, the complexities of the bitemporal data modelling is unwanted complexity, and as such, better left out.\n"
type RoleBindingResponse {
  """UUID of the bitemporal object"""
  uuid: UUID!

  "Bitemporal state entrypoint.\n\nReturns the state of the object at varying validities and varying assertion times.\n\nA list of bitemporal container objects are returned, each containing many different validity intervals.\n\nNote:\nThis the entrypoint should only be used for bitemporal integrations and UIs, such as for auditing purposes.\nFor temporal integration, please consider using `objects` instead.\nFor actual-state integrations, please consider using `current` instead.\n\n**Warning**:\nThis entrypoint should **not** be used to implement event-driven integrations.\nSuch integration should rather utilize the AMQP-based event-system.\n"
  registrations(
    filter: ModelsUuidsBoundRegistrationFilter

    "\nLimit the maximum number of elements to fetch.\n\n| `limit`      | \\# elements fetched |\n|--------------|---------------------|\n| not provided | All                 |\n| `null`       | All                 |\n| `0`          | `0` (`*`)           |\n| `x`          | Between `0` and `x` |\n\n`*`: This behavior is equivalent to SQL's `LIMIT 0` behavior.\n\nNote:\n\nSometimes the caller may receieve a shorter list (or even an empty list) of results compared to the expected per the limit argument.\n\nThis may seem confusing, but it is the expected behavior given the way that limiting is implemented in the bitemporal database layer, combined with how filtering and object change consolidation is handled.\n\nNot to worry; all the expected elements will eventually be returned, as long as the iteration is continued until the `next_cursor` is `null`.\n"
    limit: int = null

    "Cursor defining the next elements to fetch.\n\n| `cursor`       | Next element is    |\n|----------------|--------------------|\n| not provided   | First              |\n| `null`         | First              |\n| `\"MA==\"` (`*`) | First after Cursor |\n\n`*`: Placeholder for the cursor returned by the previous iteration.\n"
    cursor: Cursor = null
  ): [Registration!]!

  "Actual / current state entrypoint.\n\nReturns the state of the object at current validity and current assertion time.\n\nA single object is returned as only one validity can be active at a given assertion time.\n\nNote:\nThis the entrypoint is appropriate to use for actual-state integrations and UIs.\n"
  current(at: DateTime): RoleBinding

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  objects(start: DateTime, end: DateTime): [RoleBinding!]! @deprecated(reason: "\nWill be removed in a future version of GraphQL.\nUse validities instead.\n")

  "Temporal state entrypoint.\n\nReturns the state of the object at varying validities and current assertion time.\n\nA list of objects are returned as only many different validity intervals can be active at a given assertion time.\n\nNote:\nThis the entrypoint should be used for temporal integrations and UIs.\nFor actual-state integrations, please consider using `current` instead.\n"
  validities(start: DateTime, end: DateTime): [RoleBinding!]!
}

"""Result page in cursor-based pagination."""
type RoleBindingResponsePaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [RoleBindingResponse!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

input RoleBindingTerminateInput {
  """Start date of the validity."""
  from: DateTime = null

  """When the validity should end - required when terminating"""
  to: DateTime!

  """UUID of the role we want to terminate."""
  uuid: UUID!
}

input RoleBindingUpdateInput {
  """UUID of the role to be updated."""
  uuid: UUID!

  """Extra info or uuid."""
  user_key: String = null

  """UUID of the role's organisation unit to be updated."""
  org_unit: UUID = null

  """UUID of the ituser"""
  ituser: UUID!

  """UUID of the role type"""
  role: UUID = null

  """Validity range for the role to be updated."""
  validity: RAValidityInput!
}

"""Role registration filter."""
input RoleRegistrationFilter {
  "Filter registrations by their changing actor.\n\nCan be used to select all changes made by a particular user or integration.\n\n| `actors`      | Elements returned                            |\n|--------------|----------------------------------------------|\n| not provided | All                                          |\n| `null`       | All                                          |\n| `[]`         | None                                         |\n| `\"x\"`        | `[\"x\"]` or `[]` (`*`)                        |\n| `[\"x\", \"y\"]` | `[\"x\", \"y\"]`, `[\"x\"]`, `[\"y\"]` or `[]` (`*`) |\n\n`*`: Elements returned depends on which elements were found.\n"
  actors: [UUID!] = null

  """Limit the elements returned by their starting validity."""
  start: DateTime = null

  """Limit the elements returned by their ending validity."""
  end: DateTime = null
}

scalar UUID

"""Result page in cursor-based pagination."""
type UUIDPaged {
  "List of results.\n\nThe number of elements is defined by the `limit` argument.\n"
  objects: [UUID!]!

  "Container for page information.\n\nContains the cursors necessary to fetch other pages.\nContains information on when to stop iteration.\n"
  page_info: PageInfo!
}

scalar Upload

input UuidsBoundClassFilter {
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: ClassRegistrationFilter = null
  facet: FacetFilter = null
  facets: [UUID!] = null
  facet_user_keys: [String!] = null
  parent: ClassFilter = null
  parents: [UUID!] = null
  parent_user_keys: [String!] = null
  it_system: ITSystemFilter = null
  owner: ClassOwnerFilter = null
  scope: [String!] = null
}

input UuidsBoundEmployeeFilter {
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: EmployeeRegistrationFilter = null
  query: String
  cpr_numbers: [CPR!] = null
}

input UuidsBoundEngagementFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  employee: EmployeeFilter = null
  employees: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: EngagementRegistrationFilter = null
  job_function: ClassFilter = null
  engagement_type: ClassFilter = null
}

input UuidsBoundFacetFilter {
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: FacetRegistrationFilter = null
  parent: FacetFilter = null
  parents: [UUID!] = null
  parent_user_keys: [String!] = null
}

input UuidsBoundITSystemFilter {
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: ITSystemRegistrationFilter = null
}

input UuidsBoundITUserFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  employee: EmployeeFilter = null
  employees: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: ITUserRegistrationFilter = null
  itsystem: ITSystemFilter = null
  itsystem_uuids: [UUID!] = null
  engagement: EngagementFilter = null
  external_ids: [String!] = null
}

input UuidsBoundLeaveFilter {
  org_unit: OrganisationUnitFilter = null
  org_units: [UUID!] = null
  employee: EmployeeFilter = null
  employees: [UUID!] = null
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: LeaveRegistrationFilter = null
}

input UuidsBoundOrganisationUnitFilter {
  user_keys: [String!] = null
  from_date: DateTime
  to_date: DateTime
  registration: OrganisationUnitRegistrationFilter = null
  query: String
  names: [String!]
  parent: OrganisationUnitFilter
  parents: [UUID!]
  child: OrganisationUnitFilter
  hierarchy: ClassFilter = null
  hierarchies: [UUID!] = null
  subtree: OrganisationUnitFilter
  descendant: OrganisationUnitFilter
  ancestor: OrganisationUnitFilter
  engagement: EngagementFilter = null
}

"""Validity of objects with required from date"""
type Validity {
  """Start date of the validity."""
  from: DateTime!

  """End date of the validity, if applicable."""
  to: DateTime
}

input ValidityInput {
  """Start date of the validity."""
  from: DateTime = null

  """End date of the validity, if applicable."""
  to: DateTime = null
}

"""MO and DIPEX versions"""
type Version {
  "OS2mo Version.\n\nContains a [semantic version](https://semver.org/) on released versions of OS2mo.\nContains the string `HEAD` on development builds of OS2mo.\n\nExamples:\n* `HEAD`\n* `22.2.6`\n* `21.0.0`\n"
  mo_version: String

  "OS2mo commit hash.\n\nContains a git hash on released versions of OS2mo.\nContains the empty string on development builds of OS2mo.\n\nExamples:\n* `\"\"`\n* `880bd2009baccbdf795a8cef3b5b32b42c91c51b`\n* `b29e45449a857cf78725eff10c5856075417ea51`\n"
  mo_hash: String

  """LoRa version. Returns the exact same as `mo_version`."""
  lora_version: String @deprecated(reason: "MO and LoRa are shipped and versioned together")

  "DIPEX version.\n\nContains a [semantic version](https://semver.org/) if configured.\nContains the `null` on development builds of OS2mo.\n\nExamples:\n* `null`\n* `4.34.1`\n* `4.28.0`\n"
  dipex_version: String
}

scalar int