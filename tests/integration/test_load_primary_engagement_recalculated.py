# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from uuid import UUID
from uuid import uuid4

import pytest
from fastramqpi.context import Context
from structlog.testing import capture_logs

from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    EngagementCreateInput,
)
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    EngagementUpdateInput,
)
from mo_ldap_import_export.depends import GraphQLClient
from mo_ldap_import_export.environments.main import load_primary_engagement_recalculated


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    title = "create"
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key=title,
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            extension_1=title,
            validity={"from": "2001-02-03T04:05:06Z", "to": "2002-03-04T05:06:07Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]

    result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is None


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_deleted(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="terminated_engagement",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z", "to": "2002-03-04T05:06:07Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    with capture_logs() as cap_logs:
        result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is None

    events = [m["event"] for m in cap_logs]
    assert events == ["Could not find any engagements for employee"]


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_no_primary(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    non_primary: UUID,
) -> None:
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="non_primary_engagement",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=non_primary,
            fraction=50,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is not None
    assert result.fraction == 50


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_multiple_primaries(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="engagement1",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "2000-02-03T04:05:06Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="engagement2",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=50,
            validity={"from": "2000-02-03T04:05:06Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is not None
    assert result.user_key == "engagement1"
    assert result.fraction == 100


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_invalid_employee(context: Context) -> None:
    dataloader = context["user_context"]["dataloader"]
    employee_uuid = uuid4()
    with capture_logs() as cap_logs:
        result = await load_primary_engagement_recalculated(
            dataloader.moapi, employee_uuid
        )
    assert result is None

    events = [m["event"] for m in cap_logs]
    assert events == ["Could not find any engagements for employee"]


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_no_engagement(
    context: Context, mo_person: UUID
) -> None:
    dataloader = context["user_context"]["dataloader"]
    with capture_logs() as cap_logs:
        result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is None

    events = [m["event"] for m in cap_logs]
    assert events == ["Could not find any engagements for employee"]


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_explicitly_primary(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    non_primary: UUID,
    explicitly_primary: UUID,
) -> None:
    """Test that an explicitly primary engagement is chosen over a non-primary."""
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="10",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=non_primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="20",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=explicitly_primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is not None
    assert result.primary == explicitly_primary


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_multiple_explicitly_primary(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    explicitly_primary: UUID,
) -> None:
    """Test that multiple explicitly primary engagements raises a ValueError."""
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="10",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=explicitly_primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="20",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=explicitly_primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    with pytest.raises(ValueError) as exc_info:
        await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert str(exc_info.value) == "Multiple explicitly primary engagements found"


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_non_integer_user_key(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    """Test that non-integer user-keys are handled correctly."""
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="alpha",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="10",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is not None
    assert result.user_key == "10"


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_user_key_distinction(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    """Test that user-keys are sorted correctly to find the primary engagement."""
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="20",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="10",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is not None
    assert result.user_key == "10"


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_exclude_engagement_types(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    jurist: UUID,
    primary: UUID,
    ansat: UUID,
    praktikant: UUID,
) -> None:
    """Test that engagements of excluded types are not considered primary."""
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="10",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="20",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=praktikant,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]

    # Exclude 'Praktikant' engagement type, 'Ansat' should be primary
    result = await load_primary_engagement_recalculated(
        dataloader.moapi,
        mo_person,
        exclude_engagement_types={praktikant},
    )
    assert result is not None
    assert result.user_key == "10"

    # Exclude 'Ansat' engagement type, 'Praktikant' should be primary
    result = await load_primary_engagement_recalculated(
        dataloader.moapi,
        mo_person,
        exclude_engagement_types={ansat},
    )
    assert result is not None
    assert result.user_key == "20"

    # Exclude both 'Ansat' and 'Praktikant', no primary should be found
    result = await load_primary_engagement_recalculated(
        dataloader.moapi,
        mo_person,
        exclude_engagement_types={
            ansat,
            praktikant,
        },
    )
    assert result is None

    # No exclusion, 'ansat' should be primary (default sorting by user_key)
    result = await load_primary_engagement_recalculated(
        dataloader.moapi,
        mo_person,
    )
    assert result is not None
    assert result.user_key == "10"


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_prefers_current(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    """Test that current engagements are preferred over past and future ones."""
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="past",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "1970-01-01T00:00:00Z", "to": "2000-01-01T00:00:00Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="current",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=20,
            validity={"from": "2000-01-01T00:00:00Z", "to": "3000-01-01T00:00:00Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="future",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=50,
            validity={"from": "3000-01-01T00:00:00Z", "to": "4000-01-01T00:00:00Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is not None
    assert result.user_key == "current"


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_prefers_future(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    """Test that future engagements are preferred over past ones."""
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="past",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "1970-01-01T00:00:00Z", "to": "2000-01-01T00:00:00Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="future",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=50,
            validity={"from": "3000-01-01T00:00:00Z", "to": "4000-01-01T00:00:00Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is not None
    assert result.user_key == "future"


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_prefers_less_futuristic(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    """Test that less futuristic engagements are preferred over more futuristic ones."""
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="future",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=20,
            validity={"from": "3000-01-01T00:00:00Z", "to": "4000-01-01T00:00:00Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="far-future",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "3500-01-01T00:00:00Z", "to": "4000-01-01T00:00:00Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is not None
    assert result.user_key == "future"


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_prefers_future_validity(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
    praktikant: UUID,
) -> None:
    """Test that future engagement validities are considered."""
    engagement1 = await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="engagement1",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=praktikant,
            job_function=jurist,
            primary=primary,
            fraction=20,
            validity={"from": "2000-01-01T00:00:00Z", "to": None},
        )
    )
    engagement2 = await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="engagement2",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=praktikant,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "2000-01-01T00:00:00Z", "to": None},
        )
    )

    # Check that both are excluded and thus we cannot find a primary
    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(
        dataloader.moapi, mo_person, exclude_engagement_types={praktikant}
    )
    assert result is None

    # Modify both so they have future validities that are valid
    await graphql_client.engagement_update(
        input=EngagementUpdateInput(
            uuid=engagement1.uuid,
            engagement_type=ansat,  # This makes the new validity valid
            validity={"from": "3000-01-01T00:00:00Z", "to": None},
            # These are unchanged from the create above
            user_key="engagement1",
            person=mo_person,
            org_unit=mo_org_unit,
            job_function=jurist,
            primary=primary,
            fraction=20,
        )
    )
    await graphql_client.engagement_update(
        input=EngagementUpdateInput(
            uuid=engagement2.uuid,
            engagement_type=ansat,  # This makes the new validity valid
            validity={"from": "4000-01-01T00:00:00Z", "to": None},
            # These are unchanged from the create above
            user_key="engagement2",
            person=mo_person,
            org_unit=mo_org_unit,
            job_function=jurist,
            primary=primary,
            fraction=100,
        )
    )

    # Check that we see the future validity and get the primary
    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(
        dataloader.moapi, mo_person, exclude_engagement_types={praktikant}
    )
    assert result is not None
    assert result.user_key == "engagement1"


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_prefers_now_over_past(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    """Test that valitidies now are preferred over past ones."""

    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="engagement1",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=100,
            validity={"from": "2000-01-01T00:00:00Z", "to": None},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="engagement2",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            fraction=None,
            validity={"from": "1970-01-01T00:00:00Z", "to": None},
        )
    )

    # Check that both are excluded and thus we cannot find a primary
    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement_recalculated(dataloader.moapi, mo_person)
    assert result is not None
    assert result.user_key == "engagement1"
