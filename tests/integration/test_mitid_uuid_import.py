# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import base64
import json
import secrets
from collections.abc import Callable
from typing import Any
from unittest.mock import ANY
from uuid import UUID
from uuid import uuid4

import pytest
from fastramqpi.pytest_util import retrying
from more_itertools import one

from mo_ldap_import_export.autogenerated_graphql_client import AddressFilter
from mo_ldap_import_export.autogenerated_graphql_client import EmployeeFilter
from mo_ldap_import_export.autogenerated_graphql_client import GraphQLClient
from mo_ldap_import_export.ldapapi import LDAPAPI
from mo_ldap_import_export.utils import combine_dn_strings
from mo_ldap_import_export.utils import mo_today


@pytest.fixture
def create_mitid_alt_security_identity() -> Callable[[str], str]:
    def _create(mitid_uuid: str) -> str:
        # The format "NL3UUID-ACTIVE-NSIS" is not part of a public standard (like NSIS installer).
        # It is likely a specific format used by an Identity Broker (e.g., Signaturgruppen)
        # when synchronizing NemLog-in 3 (MitID) identities into Active Directory.
        #
        # Observed format:
        # Prefix:CVR.UUID_1.MitIDUUID.ID_1.OpaqueBlob
        
        prefix = "NL3UUID-ACTIVE-NSIS"
        
        # Viborg Kommune CVR (29189846)
        cvr = "29189846"
        
        # First UUID component (Purpose unknown: possibly Session ID, Broker ID, or Org UUID)
        uuid_1 = str(uuid4())
        
        # Integer component (8 digits in observation, purpose unknown)
        id_1 = "".join(secrets.choice("0123456789") for _ in range(8))
        
        # Opaque data (Base64 encoded)
        # Likely contains cryptographic material (signature/certificate info)
        opaque_blob = base64.b64encode(secrets.token_bytes(375)).decode("ascii")

        return f"{prefix}:{cvr}.{uuid_1}.{mitid_uuid}.{id_1}.{opaque_blob}"

    return _create


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "True",
        "CONVERSION_MAPPING": json.dumps(
            {
                "ldap_to_mo": {
                    "Employee": {
                        "objectClass": "Employee",
                        "_import_to_mo_": "false",
                        "_ldap_attributes_": [],
                        "uuid": "{{ employee_uuid or '' }}",
                    },
                    "MitIDUUID": {
                        "objectClass": "Address",
                        "_import_to_mo_": "true",
                        "_ldap_attributes_": ["carLicense"],
                        "uuid": "{{ get_address_uuid({'address_type': {'user_key': 'MitIDUUID'}, 'employee': {'uuids': [employee_uuid]}}) }}",
                        "value": "{{ ldap.carLicense | extract_mitid_uuid }}",
                        "address_type": "{{ get_employee_address_type_uuid('MitIDUUID') }}",
                        "person": "{{ employee_uuid }}",
                        "visibility": "{{ get_visibility_uuid('Public') }}",
                    },
                },
                "username_generator": {
                    "combinations_to_try": ["FFFX", "LLLX"],
                },
            }
        ),
    }
)
@pytest.mark.usefixtures("test_client", "mitid_uuid_address_type")
async def test_mitid_import(
    graphql_client: GraphQLClient,
    mo_person: UUID,
    ldap_api: LDAPAPI,
    ldap_org_unit: list[str],
    create_mitid_alt_security_identity: Callable[[str], str],
) -> None:
    async def get_address() -> dict[str, Any] | None:
        addresses = await graphql_client._testing__address_read(
            filter=AddressFilter(
                employee=EmployeeFilter(uuids=[mo_person]),
            ),
        )
        if not addresses.objects:
            return None
        address = one(addresses.objects)
        validities = one(address.validities)
        return validities.dict()

    person_dn = combine_dn_strings(["uid=abk"] + ldap_org_unit)
    mitid_uuid = str(uuid4())
    alt_sec_id = create_mitid_alt_security_identity(mitid_uuid)

    # LDAP: Create
    await ldap_api.ldap_connection.ldap_add(
        dn=person_dn,
        object_class=["top", "person", "organizationalPerson", "inetOrgPerson"],
        attributes={
            "objectClass": ["top", "person", "organizationalPerson", "inetOrgPerson"],
            "ou": "os2mo",
            "cn": "Aage Bach Klarskov",
            "sn": "Bach Klarskov",
            "employeeNumber": "2108613133",
            "carLicense": [alt_sec_id],
        },
    )

    expected_mo_address = {
        "uuid": ANY,
        "user_key": ANY,
        "address_type": {"user_key": "MitIDUUID"},
        "value": mitid_uuid,
        "value2": None,
        "person": [{"uuid": mo_person}],
        "visibility": {"user_key": "Public"},
        "validity": {"from_": mo_today(), "to": None},
    }

    async for attempt in retrying():
        with attempt:
            assert await get_address() == expected_mo_address
