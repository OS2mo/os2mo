# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from uuid import UUID

from sqlalchemy import DateTime
from sqlalchemy import String
from sqlalchemy import UniqueConstraint
from sqlalchemy import select
from sqlalchemy.dialects.postgresql import insert
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
from sqlalchemy.sql import func

from mora import exceptions

from ._common import Base


class FileToken(Base):
    __tablename__ = "file_tokens"

    id: Mapped[int] = mapped_column(primary_key=True)
    created_at: Mapped[DateTime] = mapped_column(
        DateTime(timezone=True), default=func.now()
    )
    secret: Mapped[str] = mapped_column(String(255), nullable=False)


class _File(Base):
    """MO has support for a very simple file upload facility.

    From the outside, MO has two file stores: "exports" and "insights". Files
    uploaded as "exports" are used for small reports generated by integrations.
    Files uploaded as "insights" are displayed in the "Insights" module.
    """

    __tablename__ = "file"

    id: Mapped[int] = mapped_column(primary_key=True)
    created_at: Mapped[DateTime] = mapped_column(
        DateTime(timezone=True), default=func.now()
    )

    # actor serves as the write-audit log here, as files are not bi-temporal
    # (usually the actor is stored in the registration).
    actor: Mapped[UUID]

    store: Mapped[str]  # actually a FileStore such as "EXPORTS"
    name: Mapped[str]
    content: Mapped[bytes]

    __table_args__ = (UniqueConstraint("store", "name", name="uix_store_name"),)


async def ls(session, filter) -> set[str]:
    """List all files in matching the filter."""
    query = select(_File.name).where(_File.store == filter.file_store.name)
    if filter.file_names:
        query = query.where(_File.name.in_(filter.file_names))
    return set(await session.scalars(query))


async def write(
    session,
    actor: UUID,
    file_store,
    file_name: str,
    data: bytes,
    force: bool,
) -> None:
    """Write a file to a file_store.

    Use *force* to overwrite the file, if it exists.

    If the file already exists and *force* is False, raise E_ALREADY_EXISTS.
    """
    query = insert(_File).values(
        actor=actor, store=file_store.name, name=file_name, content=data
    )
    if force:
        query = query.on_conflict_do_update(
            constraint="uix_store_name",
            set_=dict(actor=actor, content=data),
        )
        await session.execute(query)
    else:
        try:
            await session.execute(query)
        except IntegrityError:
            exceptions.ErrorCodes.E_ALREADY_EXISTS(filename=file_name)


async def read(session, file_store, file_name: str) -> bytes:
    """Read content of *file_name* from *file_store*."""
    return await session.scalar(
        select(_File.content).where(_File.store == file_store, _File.name == file_name)
    )
